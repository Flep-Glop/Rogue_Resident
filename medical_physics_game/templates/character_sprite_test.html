<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Advanced Character Animation Tester</title>
<style>
/* Base styles */
body {
    background-color: #121218;
    color: #ffffff;
    font-family: Arial, sans-serif;
    padding: 20px;
    margin: 0;
}

.test-container {
    max-width: 950px;
    margin: 20px auto;
    padding: 20px;
    background-color: #1e1e2a;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

h1 {
    text-align: center;
    margin-bottom: 20px;
    color: #5b8dd9;
    font-size: 28px;
}

/* Character selection panel */
.character-select-panel {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
    padding: 10px;
    background-color: #292936;
    border-radius: 8px;
    border: 1px solid #3d4c60;
}

.character-button {
    padding: 8px 15px;
    background-color: #3d4c60;
    border: 2px solid transparent;
    border-radius: 5px;
    color: white;
    cursor: pointer;
    transition: all 0.2s;
}

.character-button:hover {
    background-color: #4a5d75;
    transform: translateY(-2px);
}

.character-button.active {
    border-color: #5b8dd9;
    background-color: #4a5d75;
    box-shadow: 0 0 10px rgba(91, 141, 217, 0.5);
}

/* Character display area */
.character-display {
    display: flex;
    justify-content: center;
    margin-bottom: 30px;
    gap: 20px;
}

.character-view {
    width: 320px;
    padding: 15px;
    border: 2px solid #5b8dd9;
    border-radius: 8px;
    background-color: #292936;
}

.stats-view {
    width: 260px;
    padding: 15px;
    border: 2px solid #56b886;
    border-radius: 8px;
    background-color: #292936;
    display: flex;
    flex-direction: column;
}

.character-details {
    text-align: center;
}

.character-name {
    margin-bottom: 10px;
    color: #5b8dd9;
    font-size: 18px;
    font-weight: bold;
}

.character-avatar-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 0 auto 10px;
    position: relative;
    width: 100%;
    text-align: center;
}

.character-avatar {
    width: 160px;
    height: 160px;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden; /* Default to hidden, can be toggled */
    background-color: rgba(0, 0, 0, 0.3);
    border: 2px solid #3d4c60;
    border-radius: 5px;
    margin: 15px auto;
    box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
}

/* Key spritesheet animation styles - IMPROVED */
.sprite-container {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
}

.character-sprite {
    position: absolute;
    height: 100%;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    -webkit-font-smoothing: none;
    will-change: transform; /* Performance optimization */
}

.character-sprite.wide-sprite {
    width: auto;
    max-width: none;
}

.character-avatar.ability-mode {
    overflow: visible !important;
}

/* Animation info section */
.animation-info {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.2);
    border-radius: 5px;
}

.animation-info div {
    display: flex;
    flex-direction: column;
}

.info-label {
    font-size: 12px;
    color: #a7adb5;
}

.info-value {
    font-size: 14px;
    color: #5b8dd9;
    font-weight: bold;
}

/* Control Panels */
.controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-top: 20px;
}

.control-panel {
    background-color: #292936;
    border: 1px solid #3d4c60;
    border-radius: 8px;
    padding: 15px;
}

.control-panel h3 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #d4dae0;
    text-align: center;
    font-size: 16px;
    border-bottom: 1px solid #3d4c60;
    padding-bottom: 8px;
}

.button-group {
    display: flex;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 15px;
}

button {
    background-color: #3d4c60;
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
}

button:hover {
    background-color: #4a5d75;
    transform: translateY(-2px);
}

button:active {
    transform: translateY(0);
}

button.primary {
    background-color: #5b8dd9;
}

button.success {
    background-color: #56b886;
}

button.danger {
    background-color: #e67e73;
}

button.special {
    background-color: #d35db3;
    padding: 10px 15px;
    font-weight: bold;
    box-shadow: 0 0 10px rgba(211, 93, 179, 0.3);
}

/* Debug controls */
.range-control {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.range-control label {
    width: 100px;
    font-size: 14px;
}

.range-control input {
    flex: 1;
}

.range-value {
    width: 50px;
    text-align: center;
    font-size: 14px;
    color: #5b8dd9;
}

/* Debug log section */
.debug-section {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-top: 20px;
}

.debug-panel {
    background-color: #292936;
    border: 1px solid #3d4c60;
    border-radius: 8px;
    padding: 15px;
}

.debug-panel h3 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #d4dae0;
    text-align: center;
    font-size: 16px;
    border-bottom: 1px solid #3d4c60;
    padding-bottom: 8px;
}

.debug-log {
    height: 200px;
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 5px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 12px;
}

.debug-log p {
    margin: 5px 0;
    color: #a7adb5;
}

.debug-log p.info {
    color: #5b8dd9;
}

.debug-log p.success {
    color: #56b886;
}

.debug-log p.error {
    color: #e67e73;
}

.debug-log p.warning {
    color: #f0c866;
}

/* Animation visualizer */
.debug-visualizer {
    height: 200px;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 5px;
    position: relative;
    overflow: hidden;
}

.frame-counter {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(0, 0, 0, 0.5);
    padding: 5px 10px;
    border-radius: 3px;
    font-size: 12px;
    color: #5b8dd9;
    font-family: monospace;
}

.frame-timeline {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 30px;
    width: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    padding: 5px;
    box-sizing: border-box;
}

.frame-marker {
    flex: 1;
    height: 100%;
    background-color: #3d4c60;
    margin: 0 1px;
    transition: background-color 0.2s;
}

.frame-marker.active {
    background-color: #5b8dd9;
}

/* Function test panel */
.function-test-panel {
    margin-top: 20px;
    background-color: #292936;
    border: 1px solid #3d4c60;
    border-radius: 8px;
    padding: 15px;
}

.function-test-panel h3 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #d4dae0;
    text-align: center;
    font-size: 16px;
    border-bottom: 1px solid #3d4c60;
    padding-bottom: 8px;
}

.function-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}

.function-result {
    margin-top: 15px;
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 5px;
    font-family: monospace;
    font-size: 12px;
    max-height: 150px;
    overflow-y: auto;
}

/* Image test panel */
.image-test-panel {
    margin-top: 20px;
    background-color: #292936;
    border: 1px solid #3d4c60;
    border-radius: 8px;
    padding: 15px;
}

.image-test-panel h3 {
    margin-top: 0;
    margin-bottom: 15px;
    color: #d4dae0;
    text-align: center;
    font-size: 16px;
    border-bottom: 1px solid #3d4c60;
    padding-bottom: 8px;
}

.image-test-controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 15px;
}

.image-test-form {
    display: flex;
    gap: 10px;
}

.image-test-form input {
    flex: 1;
    padding: 8px 12px;
    background-color: #1e1e2a;
    border: 1px solid #3d4c60;
    border-radius: 5px;
    color: white;
}

.image-display {
    margin-top: 15px;
    height: 150px;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #a7adb5;
}

.image-display img {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
}

/* Character stats styling */
.character-stat {
    margin-bottom: 12px;
}

.stat-label {
    display: flex;
    justify-content: space-between;
    font-size: 14px;
    margin-bottom: 5px;
}

.stat-name {
    color: #d4dae0;
}

.stat-value {
    color: #5b8dd9;
    font-weight: bold;
}

.stat-bar {
    height: 8px;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    overflow: hidden;
}

.stat-fill {
    height: 100%;
    transition: width 0.3s;
}

.stat-fill.lives {
    background-color: #e67e73;
}

.stat-fill.insight {
    background-color: #5b8dd9;
}

.stat-fill.level {
    background-color: #f0c866;
}

.special-ability {
    margin-top: auto;
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.2);
    border-radius: 5px;
}

.ability-header {
    font-size: 14px;
    color: #f0c866;
    margin-bottom: 5px;
}

.ability-description {
    font-size: 12px;
    color: #d4dae0;
    line-height: 1.4;
}

/* Animation Effects */
@keyframes ability-flash {
    0% { filter: brightness(1); }
    50% { filter: brightness(1.5) saturate(1.5); }
    100% { filter: brightness(1); }
}

.ability-flash {
    animation: ability-flash 0.5s ease-in-out;
}

/* Debug grid */
.debug-grid {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    border: 1px dashed rgba(255, 255, 255, 0.3);
    z-index: 5;
    display: none;
}

.debug-grid::before, .debug-grid::after {
    content: '';
    position: absolute;
    background-color: rgba(255, 255, 255, 0.2);
}

.debug-grid::before {
    top: 0;
    bottom: 0;
    left: 50%;
    width: 1px;
    transform: translateX(-0.5px);
}

.debug-grid::after {
    left: 0;
    right: 0;
    top: 50%;
    height: 1px;
    transform: translateY(-0.5px);
}

.show-grid .debug-grid {
    display: block;
}

/* Tooltip styling */
.tooltip {
    position: relative;
    display: inline-block;
}

.tooltip .tooltip-text {
    visibility: hidden;
    width: 120px;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    text-align: center;
    border-radius: 6px;
    padding: 5px;
    position: absolute;
    z-index: 100;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    font-size: 12px;
}

.tooltip:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
}

/* Loading indicator */
.loading-spinner {
    width: 24px;
    height: 24px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #5b8dd9;
    animation: spin 1s linear infinite;
    margin: 0 auto;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}
</style>
</head>
<body>
<div class="test-container">
<h1>Advanced Character Animation Tester</h1>

<!-- Character Selection -->
<div class="character-select-panel">
    <button class="character-button active" data-character="resident">Resident</button>
    <button class="character-button" data-character="physicist">Physicist</button>
    <button class="character-button" data-character="qa_specialist">QA Specialist</button>
    <button class="character-button" data-character="debug_mode">Debug Mode</button>
</div>

<!-- Character Display -->
<div class="character-display">
    <div class="character-view">
        <div class="character-details">
            <p class="character-name" id="character-name">Medical Physics Resident</p>
            <div class="character-avatar-container">
                <div class="character-avatar" id="character-avatar">
                    <div id="character-sprite-container"></div>
                    <div class="debug-grid"></div>
                </div>
            </div>
            
            <!-- Animation Info -->
            <div class="animation-info">
                <div>
                    <span class="info-label">Current Animation</span>
                    <span class="info-value" id="current-animation">idle</span>
                </div>
                <div>
                    <span class="info-label">Frame</span>
                    <span class="info-value" id="current-frame">1</span>
                </div>
                <div>
                    <span class="info-label">State</span>
                    <span class="info-value" id="animation-state">playing</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Character Stats -->
    <div class="stats-view">
        <div class="character-stat">
            <div class="stat-label">
                <span class="stat-name">Lives</span>
                <span class="stat-value" id="lives-stat">3/3</span>
            </div>
            <div class="stat-bar">
                <div class="stat-fill lives" style="width: 100%"></div>
            </div>
        </div>
        
        <div class="character-stat">
            <div class="stat-label">
                <span class="stat-name">Insight</span>
                <span class="stat-value" id="insight-stat">20</span>
            </div>
            <div class="stat-bar">
                <div class="stat-fill insight" style="width: 20%"></div>
            </div>
        </div>
        
        <div class="character-stat">
            <div class="stat-label">
                <span class="stat-name">Level</span>
                <span class="stat-value" id="level-stat">1</span>
            </div>
            <div class="stat-bar">
                <div class="stat-fill level" style="width: 10%"></div>
            </div>
        </div>
        
        <div class="special-ability">
            <div class="ability-header" id="ability-name">Literature Review</div>
            <div class="ability-description" id="ability-description">
                Once per floor, can skip a question node without penalty.
            </div>
        </div>
    </div>
</div>

<!-- Control Panels -->
<div class="controls">
    <!-- Basic Animation Controls -->
    <div class="control-panel">
        <h3>Animation Controls</h3>
        <div class="button-group">
            <button id="btn-idle" class="primary tooltip">
                Idle
                <span class="tooltip-text">Play idle animation</span>
            </button>
            <button id="btn-walk" class="tooltip">
                Walk
                <span class="tooltip-text">Play walking animation</span>
            </button>
            <button id="btn-ability" class="tooltip">
                Regular Ability
                <span class="tooltip-text">Play normal ability animation</span>
            </button>
            <button id="btn-special-ability" class="special tooltip">
                Special Ability
                <span class="tooltip-text">Play wide special ability animation</span>
            </button>
        </div>
        
        <div class="button-group">
            <button id="btn-play" class="success tooltip">
                Play
                <span class="tooltip-text">Resume animation</span>
            </button>
            <button id="btn-pause" class="tooltip">
                Pause
                <span class="tooltip-text">Pause animation</span>
            </button>
            <button id="btn-stop" class="danger tooltip">
                Stop
                <span class="tooltip-text">Stop animation</span>
            </button>
            <button id="btn-reset" class="tooltip">
                Reset
                <span class="tooltip-text">Reset to first frame</span>
            </button>
        </div>
    </div>
    
    <!-- Debug Tools -->
    <div class="control-panel">
        <h3>Debug Tools</h3>
        
        <div class="range-control">
            <label for="scale-range">Scale:</label>
            <input type="range" id="scale-range" min="1" max="5" step="0.5" value="3">
            <span class="range-value" id="scale-value">3.0</span>
        </div>
        
        <div class="range-control">
            <label for="speed-range">Speed:</label>
            <input type="range" id="speed-range" min="50" max="500" step="10" value="200">
            <span class="range-value" id="speed-value">200ms</span>
        </div>
        
        <div class="button-group">
            <button id="btn-toggle-grid" class="tooltip">
                Toggle Grid
                <span class="tooltip-text">Show/hide alignment grid</span>
            </button>
            <button id="btn-toggle-overflow" class="tooltip">
                Toggle Overflow
                <span class="tooltip-text">Show/hide content outside boundaries</span>
            </button>
            <button id="btn-toggle-loop" class="tooltip">
                Toggle Looping
                <span class="tooltip-text">Enable/disable animation looping</span>
            </button>
            <button id="btn-toggle-wide" class="tooltip">
                Toggle Wide Mode
                <span class="tooltip-text">Enable/disable wide sprite container</span>
            </button>
        </div>
    </div>
</div>

<!-- Debug Section -->
<div class="debug-section">
    <!-- Debug Log -->
    <div class="debug-panel">
        <h3>Debug Log</h3>
        <div class="debug-log" id="debug-log">
            <p>Animation debug log:</p>
        </div>
    </div>
    
    <!-- Animation Visualizer -->
    <div class="debug-panel">
        <h3>Animation Visualizer</h3>
        <div class="debug-visualizer">
            <div class="frame-counter" id="frame-counter">Frame: 1/4</div>
            <div class="frame-timeline" id="frame-timeline">
                <!-- Frame markers will be added dynamically -->
            </div>
        </div>
    </div>
</div>

<!-- Function Testing Panel -->
<div class="function-test-panel">
    <h3>Function Testing</h3>
    <div class="function-buttons">
        <button id="test-get-character">Test getCharacter()</button>
        <button id="test-get-animations">Test getCharacterAnimations()</button>
        <button id="test-animation-data">Test getCharacterAnimation()</button>
        <button id="test-create-anim">Test createAnimation()</button>
        <button id="test-play-anim">Test playAnimation()</button>
        <button id="test-ability-anim">Test playAbilityAnimation()</button>
    </div>
    <div class="function-result" id="function-result">
        <p>Function test results will appear here.</p>
    </div>
</div>

<!-- Image Testing Section -->
<div class="image-test-panel">
    <h3>Character Image Tester</h3>
    <div class="image-test-controls">
        <form class="image-test-form" id="image-test-form">
            <input type="text" id="image-path-input" placeholder="/static/img/characters/resident/idle.png" value="/static/img/characters/resident/idle.png">
            <button type="submit" class="primary">Load Image</button>
        </form>
    </div>
    <div class="image-display" id="image-display">
        <div>Enter a path to test image loading</div>
    </div>
    <div class="image-test-result" id="image-test-result"></div>
</div>

<script>
/**
 * IMPROVED CHARACTER ANIMATION SYSTEM
 * - Fixed spritesheet segmentation issues
 * - Improved animation timing with proper requestAnimationFrame usage
 * - Enhanced error handling and debugging
 * - Optimized performance
 */

// ====================================================
// MODULE 1: CHARACTER DATA MANAGER
// ====================================================
const CharacterDataManager = {
    // Character data repository
    characters: {
        resident: {
            name: "Resident",
            description: "A new medical physics resident.",
            imagePath: "/static/img/characters/resident/idle.png",
            spritePath: "/static/img/characters/resident/",
            animations: {
                idle: {
                    file: "idle.png", 
                    frames: 1
                },
                walking: {
                    file: "walking.png", 
                    frames: 4, 
                    speed: 250
                },
                ability: {
                    file: "ability.png", 
                    frames: 6, 
                    speed: 120
                },
                specialAbility: {
                    file: "special_ability.png", 
                    frames: 10, 
                    speed: 80,
                    aspectRatio: 2.5 // Wider sprite
                }
            },
            stats: {
                startingInsight: 20,
                startingLives: 3,
                maxLives: 3,
                level: 1
            },
            special_ability: {
                name: "Literature Review",
                description: "Once per floor, can skip a question node without penalty.",
                uses_per_floor: 1
            }
        },
        physicist: {
            name: "Junior Physicist",
            description: "More experienced with treatment planning but fewer lives.",
            imagePath: "/static/img/characters/physicist/portrait.png",
            spritePath: "/static/img/characters/physicist/",
            animations: {
                idle: {
                    file: "idle.png", 
                    frames: 1
                },
                walking: {
                    file: "walking.png", 
                    frames: 4, 
                    speed: 250
                },
                ability: {
                    file: "ability.png", 
                    frames: 6, 
                    speed: 120
                },
                specialAbility: {
                    file: "special_ability.png", 
                    frames: 10, 
                    speed: 80,
                    aspectRatio: 2.5
                }
            },
            stats: {
                startingInsight: 30,
                startingLives: 2,
                maxLives: 2,
                level: 1
            },
            special_ability: {
                name: "Peer Review",
                description: "Can see the correct answer for one question per floor.",
                uses_per_floor: 1
            }
        },
        qa_specialist: {
            name: "QA Specialist",
            description: "Quality Assurance expert with deep knowledge of machine checks.",
            imagePath: "/static/img/characters/qa_specialist/portrait.png",
            spritePath: "/static/img/characters/qa_specialist/",
            animations: {
                idle: {
                    file: "idle.png", 
                    frames: 1
                },
                walking: {
                    file: "walking.png", 
                    frames: 4, 
                    speed: 250
                },
                ability: {
                    file: "ability.png", 
                    frames: 6, 
                    speed: 120
                },
                specialAbility: {
                    file: "special_ability.png", 
                    frames: 10, 
                    speed: 80,
                    aspectRatio: 2.5
                }
            },
            stats: {
                startingInsight: 25,
                startingLives: 3,
                maxLives: 3,
                level: 1
            },
            special_ability: {
                name: "Measurement Uncertainty",
                description: "Can retry one failed question per floor.",
                uses_per_floor: 1
            }
        },
        debug_mode: {
            name: "Debug Physicist",
            description: "A special character with godlike powers for testing purposes.",
            imagePath: "/static/img/characters/debug_mode/portrait.png",
            spritePath: "/static/img/characters/debug_mode/",
            animations: {
                idle: {
                    file: "idle.png", 
                    frames: 1
                },
                walking: {
                    file: "walking.png", 
                    frames: 4, 
                    speed: 250
                },
                ability: {
                    file: "ability.png", 
                    frames: 6, 
                    speed: 120
                },
                specialAbility: {
                    file: "special_ability.png", 
                    frames: 10, 
                    speed: 80,
                    aspectRatio: 2.5
                }
            },
            stats: {
                startingInsight: 999,
                startingLives: 99,
                maxLives: 99,
                level: 42
            },
            special_ability: {
                name: "Debug Override",
                description: "Can instantly complete any node without penalties.",
                uses_per_floor: 999
            }
        }
    },
    
    // Get all character keys
    getCharacterKeys: function() {
        return Object.keys(this.characters);
    },
    
    // Get character data by key
    getCharacter: function(key) {
        return this.characters[key] || null;
    },
    
    // Get character portrait image path
    getCharacterImagePath: function(key) {
        const character = this.getCharacter(key);
        return character ? character.imagePath : '/static/img/characters/resident/portrait.png';
    },
    
    // Get sprite path for a specific animation
    getCharacterSpritePath: function(key, animation = "idle") {
        const character = this.getCharacter(key);
        if (!character || !character.animations || !character.animations[animation]) {
            return null;
        }
        
        return character.spritePath + character.animations[animation].file;
    },
    
    // Get animation data for a character
    getCharacterAnimation: function(key, animation = "idle") {
        const character = this.getCharacter(key);
        if (!character || !character.animations) return null;
        
        return character.animations[animation] || character.animations.idle;
    },
    
    // Get all available animations for a character
    getCharacterAnimations: function(key) {
        const character = this.getCharacter(key);
        if (!character || !character.animations) return [];
        
        return Object.keys(character.animations);
    },
    
    // Get character ID from name
    getCharacterIdFromName: function(name) {
        for (const id in this.characters) {
            if (this.characters[id].name === name) {
                return id;
            }
        }
        return 'resident';
    },
    
    // Convert character ID to name
    getCharacterNameFromId: function(id) {
        const character = this.getCharacter(id);
        return character ? character.name : "Medical Physics Resident";
    }
};

// Make the CharacterDataManager globally available as CharacterAssets for backward compatibility
window.CharacterAssets = CharacterDataManager;

// ====================================================
// MODULE 2: DEBUG UTILITY SYSTEM
// ====================================================
const DebugSystem = {
    // Initialize the debug system
    initialize: function() {
        this.logContainer = document.getElementById('debug-log');
        return this;
    },
    
    // Log levels with corresponding methods
    log: function(message) {
        console.log(message);
        this._addLogEntry(message);
    },
    
    info: function(message) {
        console.info(message);
        this._addLogEntry(message, 'info');
    },
    
    success: function(message) {
        console.log('%c' + message, 'color: green');
        this._addLogEntry(message, 'success');
    },
    
    error: function(message) {
        console.error(message);
        this._addLogEntry(message, 'error');
    },
    
    warning: function(message) {
        console.warn(message);
        this._addLogEntry(message, 'warning');
    },
    
    // Clear the debug log
    clear: function() {
        if (this.logContainer) {
            this.logContainer.innerHTML = '';
            this._addLogEntry('Log cleared', 'info');
        }
    },
    
    // Add entry to the visual log
    _addLogEntry: function(message, type = '') {
        if (!this.logContainer) return;
        
        const entry = document.createElement('p');
        if (type) entry.className = type;
        
        // Add timestamp
        const now = new Date();
        const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}.${now.getMilliseconds().toString().padStart(3, '0')}`;
        
        entry.textContent = `[${timestamp}] ${message}`;
        
        this.logContainer.appendChild(entry);
        this.logContainer.scrollTop = this.logContainer.scrollHeight;
    },
    
    // Update the frame timeline visualization
    updateFrameTimeline: function(frameCount) {
        const timeline = document.getElementById('frame-timeline');
        if (!timeline) return;
        
        timeline.innerHTML = '';
        
        for (let i = 0; i < frameCount; i++) {
            const marker = document.createElement('div');
            marker.className = 'frame-marker';
            marker.dataset.frameIndex = i;
            
            if (i === 0) {
                marker.classList.add('active');
            }
            
            timeline.appendChild(marker);
        }
    },
    
    // Update active frame in timeline
    updateActiveFrame: function(frameIndex) {
        const markers = document.querySelectorAll('.frame-marker');
        markers.forEach((marker, index) => {
            if (index === frameIndex) {
                marker.classList.add('active');
            } else {
                marker.classList.remove('active');
            }
        });
    },
    
    // Update frame counter display
    updateFrameCounter: function(currentFrame, totalFrames) {
        const counter = document.getElementById('frame-counter');
        if (counter) {
            counter.textContent = `Frame: ${currentFrame}/${totalFrames}`;
        }
        
        const currentFrameElement = document.getElementById('current-frame');
        if (currentFrameElement) {
            currentFrameElement.textContent = currentFrame;
        }
    },
    
    // Update animation state display
    updateAnimationState: function(state) {
        const stateElement = document.getElementById('animation-state');
        if (stateElement) {
            stateElement.textContent = state;
        }
    }
};

// ====================================================
// MODULE 3: IMPROVED ANIMATION SYSTEM
// ====================================================
const AnimationSystem = {
    // Active animations registry
    activeAnimations: {},
    
    // Global settings
    settings: {
        loopEnabled: true,
        debugMode: true
    },
    
    // Initialize the animation system
    initialize: function() {
        DebugSystem.info("Animation System initialized");
        
        // Set up frame timeline visualization
        DebugSystem.updateFrameTimeline(4); // Default to 4 frames
        
        // Set up animation event listeners
        window.addEventListener('resize', this._handleWindowResize.bind(this));
        document.addEventListener('visibilitychange', this._handleVisibilityChange.bind(this));
        
        return this;
    },
    
    // Create a new animation instance - IMPROVED
    createAnimation: function(characterId, containerId, options = {}) {
        // Parameter validation
        if (!characterId || !containerId) {
            DebugSystem.error("Missing required parameters for createAnimation");
            return null;
        }
        
        // Get target container
        const container = document.getElementById(containerId);
        if (!container) {
            DebugSystem.error(`Animation container not found: ${containerId}`);
            return null;
        }
        
        try {
            // Clear container content
            container.innerHTML = '';
            
            // Default animation options
            const defaultOptions = {
                initialAnimation: 'idle',
                autoPlay: true,
                loop: this.settings.loopEnabled,
                scale: 3,
                centerImage: true,
                adaptiveWidth: false
            };
            
            // Merge with provided options
            const animOptions = {...defaultOptions, ...options};
            
            // Create animation container element
            const animationContainer = document.createElement('div');
            animationContainer.className = 'sprite-container';
            container.appendChild(animationContainer);
            
            // Create unique animation ID
            const animationId = `anim_${characterId}_${containerId}_${Date.now()}`;
            
            // Create animation instance
            const animation = {
                id: animationId,
                characterId: characterId,
                containerId: containerId,
                container: animationContainer,
                currentAnimation: null,
                frameIndex: 0,
                animFrame: null,
                options: animOptions,
                isPlaying: false,
                lastFrameTime: 0,
                frameTimeout: null,
                stats: {
                    framesRendered: 0,
                    startTime: 0,
                    fps: 0
                }
            };
            
            // Register the animation
            this.activeAnimations[animationId] = animation;
            
            // Start initial animation if specified
            if (animOptions.initialAnimation && animOptions.autoPlay) {
                this.playAnimation(animationId, animOptions.initialAnimation);
            }
            
            DebugSystem.success(`Created animation ${animationId} for character ${characterId}`);
            return animationId;
            
        } catch (error) {
            DebugSystem.error(`Error creating animation: ${error.message}`);
            console.error(error);
            return null;
        }
    },
    
    // Play a specific animation - COMPLETELY REWRITTEN
    playAnimation: function(animationId, animationName = 'idle', loop = null) {
        // Get animation instance
        const animation = this.activeAnimations[animationId];
        if (!animation) {
            DebugSystem.error(`Animation not found: ${animationId}`);
            return false;
        }
        
        try {
            // Stop any current animation
            this.stopAnimation(animationId);
            
            // Get animation data from character
            const animData = CharacterDataManager.getCharacterAnimation(animation.characterId, animationName);
            if (!animData) {
                DebugSystem.error(`Animation data not found for ${animationName}`);
                return false;
            }
            
            // Save current animation name
            animation.currentAnimation = animationName;
            
            // Update animation info display
            document.getElementById('current-animation').textContent = animationName;
            DebugSystem.updateAnimationState('playing');
            
            // Set looping behavior
            if (loop !== null) {
                animation.options.loop = loop;
            } else {
                // Otherwise use global setting
                animation.options.loop = this.settings.loopEnabled;
            }
            
            // CRITICAL FIX: Set up the sprite sheet animation with new approach
            this._setupSpritesheet(animation, animData);
            
            // Update frame timeline
            DebugSystem.updateFrameTimeline(animData.frames);
            
            // Set animation state
            animation.isPlaying = true;
            animation.stats.startTime = performance.now();
            animation.stats.framesRendered = 0;
            
            DebugSystem.info(`Playing animation: ${animationName} (loop: ${animation.options.loop})`);
            
            return true;
        
        } catch (error) {
            DebugSystem.error(`Error playing animation: ${error.message}`);
            console.error(error);
            return false;
        }
    },
    
    // NEW IMPLEMENTATION: Set up spritesheet animation
    _setupSpritesheet: function(animation, animData) {
        console.log("SetupSpritesheet - beginning", animation, animData);
        
        try {
            // Validate input parameters
            if (!animation || !animData) {
                throw new Error("Invalid animation or animData parameters");
            }
            
            // Clear container first
            if (!animation.container) {
                throw new Error("Animation container is undefined");
            }
            animation.container.innerHTML = '';
            
            // Get spritesheet path and full URL
            const characterId = animation.characterId;
            const animationName = animation.currentAnimation;
            
            if (!characterId || !animationName) {
                throw new Error("Missing characterId or animationName");
            }
            
            const spritesheetPath = `/static/img/characters/${characterId}/${animationName}.png`;
            console.log("Attempting to load sprite from:", spritesheetPath);
            
            // Create sprite element with proper sizing
            console.log("About to create sprite element");
            const sprite = document.createElement('div');
            console.log("Sprite element created:", sprite);
            
            sprite.className = 'character-sprite';
            console.log("Added class to sprite");
            
            // Handle aspect ratio for wide sprites
            const aspectRatio = animData.aspectRatio || 1;
            if (animation.options.adaptiveWidth && aspectRatio !== 1) {
                sprite.classList.add('wide-sprite');
                console.log("Added wide-sprite class for adaptive width");
                
                // Handle parent container overflow
                const avatarContainer = document.getElementById('character-avatar');
                if (avatarContainer) {
                    avatarContainer.classList.add('ability-mode');
                    animation.avatarContainer = avatarContainer;
                    console.log("Set avatar container to ability mode");
                }
            }
            
            // CRITICAL FIX: Set width proportional to frames for proper segmentation
            sprite.style.width = `${animData.frames * 100}%`;
            sprite.style.height = '100%';
            console.log(`Set sprite dimensions: width=${animData.frames * 100}%, height=100%`);
            
            // Set spritesheet background
            sprite.style.backgroundImage = `url(${spritesheetPath})`;
            sprite.style.backgroundRepeat = 'repeat-x';
            sprite.style.backgroundSize = `${animData.frames * 100}% 100%`;
            console.log("Set sprite background properties");
            
            // Apply scale transform
            const scale = animation.options.scale || 1;
            sprite.style.transform = `scale(${scale})`;
            console.log(`Applied scale: ${scale}`);
            
            // Add debug frame counter if in debug mode
            if (this.settings && this.settings.debugMode) {
                const frameCounter = document.createElement('div');
                frameCounter.id = 'sprite-frame-counter';
                frameCounter.style.position = 'absolute';
                frameCounter.style.bottom = '5px';
                frameCounter.style.right = '5px';
                frameCounter.style.background = 'rgba(0,0,0,0.7)';
                frameCounter.style.color = '#5b8dd9';
                frameCounter.style.padding = '2px 5px';
                frameCounter.style.borderRadius = '3px';
                frameCounter.style.fontSize = '10px';
                frameCounter.textContent = `1/${animData.frames}`;
                animation.container.appendChild(frameCounter);
                animation.frameCounter = frameCounter;
                console.log("Added debug frame counter");
            }
            
            // Test image loading before adding to DOM
            const testImg = new Image();
            testImg.onload = () => {
                console.log("✅ Image loaded successfully:", spritesheetPath);
                animation.container.appendChild(sprite);
                console.log("Sprite added to container");
            };
            testImg.onerror = () => {
                console.error("❌ Image failed to load:", spritesheetPath);
                // Add visual error indicator
                animation.container.innerHTML = `
                    <div style="color: red; padding: 10px; text-align: center;">
                        <p>Error loading image:</p>
                        <p>${spritesheetPath}</p>
                    </div>
                `;
                throw new Error(`Failed to load sprite image: ${spritesheetPath}`);
            };
            testImg.src = spritesheetPath;
            
            // Add sprite to container immediately (don't wait for image load)
            // Comment this out if you want to use the async image loading approach above
            animation.container.appendChild(sprite);
            console.log("Sprite added to container synchronously");
            
            // Store sprite reference
            animation.sprite = sprite;
            animation.frames = animData.frames;
            animation.frameSpeed = animData.speed || 200;
            console.log("Stored sprite reference and animation properties");
            
            // Set initial frame
            animation.frameIndex = 0;
            this._updateSpritePosition(animation, 0);
            console.log("Set initial frame position");
            
            // Start animation loop for multi-frame animations
            if (animData.frames > 1) {
                console.log("Starting animation loop for multi-frame animation");
                this._startAnimationLoop(animation);
            } else {
                console.log("Single frame animation - no animation loop needed");
            }
            
            // Make sure initial frame is displayed
            if (typeof DebugSystem !== 'undefined') {
                DebugSystem.updateFrameCounter(1, animData.frames);
                DebugSystem.updateActiveFrame(0);
            }
            
            // DEBUGGING - Add visible indicator for sprite position
            const debugIndicator = document.createElement('div');
            debugIndicator.style.position = 'absolute';
            debugIndicator.style.top = '0';
            debugIndicator.style.left = '0';
            debugIndicator.style.width = '10px';
            debugIndicator.style.height = '10px';
            debugIndicator.style.backgroundColor = 'red';
            debugIndicator.style.zIndex = '100';
            sprite.appendChild(debugIndicator);
            
            console.log("Spritesheet setup complete");
            return true;
            
        } catch (error) {
            console.error("Error setting up spritesheet:", error);
            if (animation && animation.container) {
                animation.container.innerHTML = `
                    <div style="color: red; padding: 10px; border: 1px solid red; background: rgba(255,0,0,0.1);">
                        <strong>Error:</strong> ${error.message}<br>
                        <small>Check console for details</small>
                    </div>
                `;
            }
            // Still define the sprite property to avoid further errors
            if (animation) {
                animation.sprite = null;
            }
            return false;
        }
    },
    
    // CRITICAL FIX: Update sprite position based on frame index
    _updateSpritePosition: function(animation, frameIndex) {
        if (!animation.sprite) return;
        
        // Calculate X position based on current frame
        const position = -(frameIndex * (100 / animation.frames));
        
        // Apply transform to move the spritesheet horizontally
        animation.sprite.style.backgroundPosition = `${position}% 0`;
        
        // Update frame counter if available
        if (animation.frameCounter) {
            animation.frameCounter.textContent = `${frameIndex + 1}/${animation.frames}`;
        }
    },
    
    // Start animation loop using requestAnimationFrame with controlled timing
    _startAnimationLoop: function(animation) {
        // Set initial time
        animation.lastFrameTime = performance.now();
        animation.stats.startTime = animation.lastFrameTime;
        
        // Frame advancement function
        const advanceFrame = () => {
            this._advanceFrame(animation.id);
        };
        
        // Animation loop function 
        const animationLoop = (timestamp) => {
            if (!animation.isPlaying) return;
            
            // Only advance frame if enough time has passed
            const elapsed = timestamp - animation.lastFrameTime;
            
            if (elapsed >= animation.frameSpeed) {
                // Update lastFrameTime tracking with adjustment to prevent drift
                animation.lastFrameTime = timestamp - (elapsed % animation.frameSpeed);
                advanceFrame();
            }
            
            // Continue animation loop
            animation.animFrame = requestAnimationFrame(animationLoop);
        };
        
        // Start the animation loop
        animation.animFrame = requestAnimationFrame(animationLoop);
    },
    
    // Advance to the next animation frame
    _advanceFrame: function(animationId) {
        // Get animation instance
        const animation = this.activeAnimations[animationId];
        if (!animation || !animation.sprite || !animation.frames) return;
        
        try {
            // Increment frame index
            animation.frameIndex = (animation.frameIndex + 1) % animation.frames;
            animation.stats.framesRendered++;
            
            // CRITICAL: Update sprite position based on new frame index
            this._updateSpritePosition(animation, animation.frameIndex);
            
            // Update UI displays
            DebugSystem.updateFrameCounter(animation.frameIndex + 1, animation.frames);
            DebugSystem.updateActiveFrame(animation.frameIndex);
            
            // If we've reached the end and not looping, stop animation
            if (animation.frameIndex === animation.frames - 1 && !animation.options.loop) {
                // Small delay to ensure the last frame is visible
                setTimeout(() => {
                    this.stopAnimation(animationId);
                    this._triggerAnimationComplete(animation);
                    this._cleanupWideMode(animation);
                    DebugSystem.updateAnimationState('stopped');
                }, 50);
            }
        } catch (error) {
            DebugSystem.error(`Error advancing animation frame: ${error.message}`);
            console.error(error);
            this.stopAnimation(animationId);
        }
    },
    
    // Trigger animation complete event
    _triggerAnimationComplete: function(animation) {
        const event = new CustomEvent('animationComplete', {
            detail: {
                animationId: animation.id,
                animationName: animation.currentAnimation,
                stats: animation.stats
            }
        });
        document.dispatchEvent(event);
        DebugSystem.success(`Animation completed: ${animation.currentAnimation}`);
    },
    
    // Clean up wide mode settings
    _cleanupWideMode: function(animation) {
        if (animation.avatarContainer) {
            animation.avatarContainer.classList.remove('ability-mode');
        }
        
        if (animation.sprite) {
            animation.sprite.classList.remove('wide-sprite');
        }
    },
    
    // Stop an animation
    stopAnimation: function(animationId) {
        const animation = this.activeAnimations[animationId];
        if (!animation) return false;
        
        // Cancel animation frame request
        if (animation.animFrame) {
            cancelAnimationFrame(animation.animFrame);
            animation.animFrame = null;
        }
        
        // Clear any timeout
        if (animation.frameTimeout) {
            clearTimeout(animation.frameTimeout);
            animation.frameTimeout = null;
        }
        
        animation.isPlaying = false;
        DebugSystem.updateAnimationState('stopped');
        
        return true;
    },
    
    // Pause an animation
    pauseAnimation: function(animationId) {
        const animation = this.activeAnimations[animationId];
        if (!animation || !animation.isPlaying) return false;
        
        // Cancel animation frame but keep state
        if (animation.animFrame) {
            cancelAnimationFrame(animation.animFrame);
            animation.animFrame = null;
        }
        
        // Clear any timeout
        if (animation.frameTimeout) {
            clearTimeout(animation.frameTimeout);
            animation.frameTimeout = null;
        }
        
        animation.isPlaying = false;
        DebugSystem.updateAnimationState('paused');
        DebugSystem.info(`Paused animation: ${animation.currentAnimation}`);
        
        return true;
    },
    
    // Resume a paused animation
    resumeAnimation: function(animationId) {
        const animation = this.activeAnimations[animationId];
        if (!animation || animation.isPlaying) return false;
        
        // Restart animation loop
        animation.lastFrameTime = performance.now();
        animation.isPlaying = true;
        this._startAnimationLoop(animation);
        
        DebugSystem.updateAnimationState('playing');
        DebugSystem.info(`Resumed animation: ${animation.currentAnimation}`);
        
        return true;
    },
    
    // Reset animation to first frame
    resetAnimation: function(animationId) {
        const animation = this.activeAnimations[animationId];
        if (!animation) return false;
        
        // Reset to first frame
        animation.frameIndex = 0;
        this._updateSpritePosition(animation, 0);
        
        // Update UI displays
        DebugSystem.updateFrameCounter(1, animation.frames);
        DebugSystem.updateActiveFrame(0);
        
        DebugSystem.info(`Reset animation: ${animation.currentAnimation}`);
        
        return true;
    },
    
    // Play ability animation with completion callback
    playAbilityAnimation: function(animationId, abilityName, onCompleteCallback) {
        const animation = this.activeAnimations[animationId];
        if (!animation) return false;
        
        try {
            // Verify animation exists
            const animData = CharacterDataManager.getCharacterAnimation(animation.characterId, abilityName);
            if (!animData) {
                DebugSystem.error(`Ability animation not found: ${abilityName}`);
                return false;
            }
            
            // Set up completion listener
            const listener = (event) => {
                if (event.detail.animationId === animationId) {
                    document.removeEventListener('animationComplete', listener);
                    
                    // Return to idle animation
                    this.playAnimation(animationId, 'idle', true);
                    
                    // Call callback if provided
                    if (onCompleteCallback && typeof onCompleteCallback === 'function') {
                        onCompleteCallback();
                    }
                }
            };
            
            document.addEventListener('animationComplete', listener);
            
            // Enable wide mode for ability animations with aspect ratio
            animation.options.adaptiveWidth = !!animData.aspectRatio && animData.aspectRatio !== 1;
            
            // Play the animation without looping
            this.playAnimation(animationId, abilityName, false);
            
            // Add flash effect to avatar
            const avatar = document.getElementById('character-avatar');
            if (avatar) {
                avatar.classList.add('ability-flash');
                setTimeout(() => {
                    avatar.classList.remove('ability-flash');
                }, 500);
            }
            
            DebugSystem.info(`Playing ability animation: ${abilityName}`);
            
            return true;
        } catch (error) {
            DebugSystem.error(`Error playing ability animation: ${error.message}`);
            console.error(error);
            return false;
        }
    },
    
    // Set animation scale
    setAnimationScale: function(animationId, scaleValue) {
        const animation = this.activeAnimations[animationId];
        if (!animation) return false;
        
        try {
            animation.options.scale = scaleValue;
            
            // Update transform of current sprite
            if (animation.sprite) {
                animation.sprite.style.transform = `scale(${scaleValue})`;
            }
            
            DebugSystem.info(`Scale set to: ${scaleValue}`);
            return true;
        } catch (error) {
            DebugSystem.error(`Error setting animation scale: ${error.message}`);
            return false;
        }
    },
    
    // Set animation speed
    setAnimationSpeed: function(animationId, speed) {
        const animation = this.activeAnimations[animationId];
        if (!animation) return false;
        
        try {
            // Update speed setting
            animation.frameSpeed = speed;
            
            DebugSystem.info(`Speed set to: ${speed}ms per frame`);
            return true;
        } catch (error) {
            DebugSystem.error(`Error setting animation speed: ${error.message}`);
            return false;
        }
    },
    
    // Toggle wide mode on/off
    toggleWideMode: function(animationId) {
        const animation = this.activeAnimations[animationId];
        if (!animation) return false;
        
        try {
            animation.options.adaptiveWidth = !animation.options.adaptiveWidth;
            
            // Reapply current animation to update container
            const currentAnim = animation.currentAnimation;
            this.playAnimation(animationId, currentAnim);
            
            DebugSystem.info(`Wide mode ${animation.options.adaptiveWidth ? 'enabled' : 'disabled'}`);
            return true;
        } catch (error) {
            DebugSystem.error(`Error toggling wide mode: ${error.message}`);
            return false;
        }
    },
    
    // Toggle global looping setting
    toggleLooping: function() {
        try {
            this.settings.loopEnabled = !this.settings.loopEnabled;
            
            // Update all active animations
            for (const animId in this.activeAnimations) {
                const animation = this.activeAnimations[animId];
                animation.options.loop = this.settings.loopEnabled;
            }
            
            DebugSystem.info(`Animation looping ${this.settings.loopEnabled ? 'enabled' : 'disabled'}`);
            return this.settings.loopEnabled;
        } catch (error) {
            DebugSystem.error(`Error toggling animation looping: ${error.message}`);
            return this.settings.loopEnabled;
        }
    },
    
    // Destroy an animation instance and clean up
    destroyAnimation: function(animationId) {
        const animation = this.activeAnimations[animationId];
        if (!animation) return false;
        
        try {
            // Stop animation first
            this.stopAnimation(animationId);
            
            // Clean up container
            if (animation.container) {
                animation.container.innerHTML = '';
            }
            
            // Remove from registry
            delete this.activeAnimations[animationId];
            
            DebugSystem.info(`Destroyed animation: ${animationId}`);
            return true;
        } catch (error) {
            DebugSystem.error(`Error destroying animation: ${error.message}`);
            return false;
        }
    },
    
    // Handle window resize event
    _handleWindowResize: function() {
        // Adjust any active animations that need sizing updates
        for (const animId in this.activeAnimations) {
            const animation = this.activeAnimations[animId];
            
            // Only re-adjust active animations
            if (animation.isPlaying && animation.currentAnimation) {
                // Restart animation to refresh layout
                const currentAnim = animation.currentAnimation;
                const isLooping = animation.options.loop;
                this.playAnimation(animId, currentAnim, isLooping);
            }
        }
    },
    
    // Handle visibility change event
    _handleVisibilityChange: function() {
        if (document.hidden) {
            // Pause all animations when tab is not visible
            for (const animId in this.activeAnimations) {
                const animation = this.activeAnimations[animId];
                if (animation.isPlaying) {
                    // Remember which animations were playing
                    animation.wasPlaying = true;
                    this.pauseAnimation(animId);
                }
            }
        } else {
            // Resume animations that were playing when tab is visible again
            for (const animId in this.activeAnimations) {
                const animation = this.activeAnimations[animId];
                if (animation.wasPlaying) {
                    animation.wasPlaying = false;
                    this.resumeAnimation(animId);
                }
            }
        }
    }
};

// ====================================================
// MODULE 4: UI CONTROLLER
// ====================================================
const UIController = {
    // State tracking
    state: {
        currentCharacterId: 'resident',
        currentAnimationId: null,
        scaleValue: 3.0,
        speedValue: 200,
        showGrid: false,
        debounceTimers: {}
    },
    
    // Initialize the UI
    initialize: function() {
        DebugSystem.info("UI Controller initialized");
        
        // Set up character selection buttons
        this._setupCharacterButtons();
        
        // Set up animation control buttons
        this._setupAnimationControls();
        
        // Set up debug tools
        this._setupDebugTools();
        
        // Set up function test buttons
        this._setupFunctionTests();
        
        // Set up image test form
        this._setupImageTester();
        
        // Load initial character
        this.loadCharacter('resident');
        
        return this;
    },
    
    // Set up character selection buttons
    _setupCharacterButtons: function() {
        document.querySelectorAll('.character-button').forEach(btn => {
            btn.addEventListener('click', () => {
                const characterId = btn.dataset.character;
                this.changeCharacter(characterId);
                
                // Update active button
                document.querySelectorAll('.character-button').forEach(b => {
                    b.classList.remove('active');
                });
                btn.classList.add('active');
            });
        });
    },
    
    // Set up animation control buttons
    _setupAnimationControls: function() {
        // Animation type buttons
        document.getElementById('btn-idle').addEventListener('click', () => {
            if (this.state.currentAnimationId) {
                AnimationSystem.playAnimation(
                    this.state.currentAnimationId, 
                    'idle', 
                    AnimationSystem.settings.loopEnabled
                );
            }
        });
        
        document.getElementById('btn-walk').addEventListener('click', () => {
            if (this.state.currentAnimationId) {
                AnimationSystem.playAnimation(
                    this.state.currentAnimationId, 
                    'walking', 
                    AnimationSystem.settings.loopEnabled
                );
            }
        });
        
        document.getElementById('btn-ability').addEventListener('click', () => {
            if (this.state.currentAnimationId) {
                AnimationSystem.playAbilityAnimation(
                    this.state.currentAnimationId, 
                    'ability', 
                    () => {
                        DebugSystem.success("Regular ability animation completed!");
                    }
                );
            }
        });
        
        document.getElementById('btn-special-ability').addEventListener('click', () => {
            if (this.state.currentAnimationId) {
                AnimationSystem.playAbilityAnimation(
                    this.state.currentAnimationId, 
                    'specialAbility', 
                    () => {
                        DebugSystem.success("Special ability animation completed!");
                    }
                );
            }
        });
        
        // Playback control buttons
        document.getElementById('btn-play').addEventListener('click', () => {
            if (this.state.currentAnimationId) {
                AnimationSystem.resumeAnimation(this.state.currentAnimationId);
            }
        });
        
        document.getElementById('btn-pause').addEventListener('click', () => {
            if (this.state.currentAnimationId) {
                AnimationSystem.pauseAnimation(this.state.currentAnimationId);
            }
        });
        
        document.getElementById('btn-stop').addEventListener('click', () => {
            if (this.state.currentAnimationId) {
                AnimationSystem.stopAnimation(this.state.currentAnimationId);
            }
        });
        
        document.getElementById('btn-reset').addEventListener('click', () => {
            if (this.state.currentAnimationId) {
                AnimationSystem.resetAnimation(this.state.currentAnimationId);
            }
        });
    },
    
    // Set up debug tools
    _setupDebugTools: function() {
        // Scale slider
        const scaleRange = document.getElementById('scale-range');
        scaleRange.addEventListener('input', this._debounce(() => {
            this.state.scaleValue = parseFloat(scaleRange.value);
            document.getElementById('scale-value').textContent = this.state.scaleValue.toFixed(1);
            
            if (this.state.currentAnimationId) {
                AnimationSystem.setAnimationScale(
                    this.state.currentAnimationId, 
                    this.state.scaleValue
                );
            }
        }, 50));
        
        // Speed slider
        const speedRange = document.getElementById('speed-range');
        speedRange.addEventListener('input', this._debounce(() => {
            this.state.speedValue = parseInt(speedRange.value);
            document.getElementById('speed-value').textContent = `${this.state.speedValue}ms`;
            
            if (this.state.currentAnimationId) {
                AnimationSystem.setAnimationSpeed(
                    this.state.currentAnimationId, 
                    this.state.speedValue
                );
            }
        }, 50));
        
        // Toggle buttons
        document.getElementById('btn-toggle-grid').addEventListener('click', () => {
            const avatar = document.getElementById('character-avatar');
            if (avatar) {
                avatar.classList.toggle('show-grid');
                this.state.showGrid = avatar.classList.contains('show-grid');
                DebugSystem.info(`Grid visibility ${this.state.showGrid ? 'enabled' : 'disabled'}`);
            }
        });
        
        document.getElementById('btn-toggle-overflow').addEventListener('click', () => {
            const avatar = document.getElementById('character-avatar');
            if (avatar) {
                if (avatar.style.overflow === 'visible') {
                    avatar.style.overflow = 'hidden';
                    DebugSystem.info("Overflow set to: hidden");
                } else {
                    avatar.style.overflow = 'visible';
                    DebugSystem.info("Overflow set to: visible");
                }
            }
        });
        
        document.getElementById('btn-toggle-loop').addEventListener('click', () => {
            const looping = AnimationSystem.toggleLooping();
            document.getElementById('btn-toggle-loop').textContent = 
                looping ? "Disable Looping" : "Enable Looping";
        });
        
        document.getElementById('btn-toggle-wide').addEventListener('click', () => {
            if (this.state.currentAnimationId) {
                AnimationSystem.toggleWideMode(this.state.currentAnimationId);
            }
        });
    },
    
    // Set up function test buttons
    _setupFunctionTests: function() {
        document.getElementById('test-get-character').addEventListener('click', () => {
            const result = CharacterDataManager.getCharacter(this.state.currentCharacterId);
            this._displayFunctionResult('getCharacter', result);
        });
        
        document.getElementById('test-get-animations').addEventListener('click', () => {
            const result = CharacterDataManager.getCharacterAnimations(this.state.currentCharacterId);
            this._displayFunctionResult('getCharacterAnimations', result);
        });
        
        document.getElementById('test-animation-data').addEventListener('click', () => {
            const result = CharacterDataManager.getCharacterAnimation(this.state.currentCharacterId, 'walking');
            this._displayFunctionResult('getCharacterAnimation', result);
        });
        
        document.getElementById('test-create-anim').addEventListener('click', () => {
            const options = {
                initialAnimation: 'idle',
                autoPlay: true,
                loop: AnimationSystem.settings.loopEnabled,
                scale: this.state.scaleValue,
                centerImage: true
            };
            
            this._displayFunctionResult('createAnimation options', options);
        });
        
        document.getElementById('test-play-anim').addEventListener('click', () => {
            const args = {
                animationId: this.state.currentAnimationId,
                animationName: 'walking',
                loop: true
            };
            
            this._displayFunctionResult('playAnimation args', args);
        });
        
        document.getElementById('test-ability-anim').addEventListener('click', () => {
            const args = {
                animationId: this.state.currentAnimationId,
                abilityName: 'specialAbility',
                onCompleteCallback: '() => { /* Callback function */ }'
            };
            
            this._displayFunctionResult('playAbilityAnimation args', args);
        });
    },
    
    // Set up image tester
    _setupImageTester: function() {
        document.getElementById('image-test-form').addEventListener('submit', (e) => {
            e.preventDefault();
            const imagePath = document.getElementById('image-path-input').value;
            this._testImageLoading(imagePath);
        });
    },
    
    // Load a character
    loadCharacter: function(characterId) {
        // Store current character ID
        this.state.currentCharacterId = characterId;
        
        // Get character data
        const character = CharacterDataManager.getCharacter(characterId);
        if (!character) {
            DebugSystem.error(`Character not found: ${characterId}`);
            return;
        }
        
        try {
            // Update character name
            document.getElementById('character-name').textContent = character.name;
            
            // Update character stats
            const stats = character.stats;
            document.getElementById('lives-stat').textContent = `${stats.startingLives}/${stats.maxLives}`;
            document.getElementById('insight-stat').textContent = stats.startingInsight;
            document.getElementById('level-stat').textContent = stats.level;
            
            // Update stat bars
            const livesFill = document.querySelector('.stat-fill.lives');
            livesFill.style.width = `${(stats.startingLives / stats.maxLives) * 100}%`;
            
            const insightFill = document.querySelector('.stat-fill.insight');
            insightFill.style.width = `${(stats.startingInsight / 100) * 100}%`;
            
            const levelFill = document.querySelector('.stat-fill.level');
            levelFill.style.width = `${(stats.level / 10) * 100}%`;
            
            // Update ability info
            document.getElementById('ability-name').textContent = character.special_ability.name;
            document.getElementById('ability-description').textContent = character.special_ability.description;
            
            // Create new animation instance
            if (this.state.currentAnimationId) {
                // Destroy any existing animation
                AnimationSystem.destroyAnimation(this.state.currentAnimationId);
            }
            
            // Create the new animation
            this.state.currentAnimationId = AnimationSystem.createAnimation(
                characterId,
                'character-sprite-container',
                {
                    initialAnimation: 'idle',
                    autoPlay: true,
                    loop: true,
                    scale: this.state.scaleValue,
                    centerImage: true
                }
            );
            
            DebugSystem.success(`Loaded character: ${character.name}`);
            
        } catch (error) {
            DebugSystem.error(`Error loading character: ${error.message}`);
            console.error(error);
        }
    },
    
    // Change character
    changeCharacter: function(characterId) {
        this.loadCharacter(characterId);
    },
    
    // Display function test results
    _displayFunctionResult: function(functionName, result) {
        const resultContainer = document.getElementById('function-result');
        resultContainer.innerHTML = '';
        
        const header = document.createElement('p');
        header.textContent = `Result of ${functionName}:`;
        header.className = 'info';
        resultContainer.appendChild(header);
        
        const resultText = document.createElement('pre');
        resultText.textContent = JSON.stringify(result, null, 2);
        resultContainer.appendChild(resultText);
        
        DebugSystem.info(`Tested function: ${functionName}`);
    },
    
    // Test image loading
    _testImageLoading: function(path) {
        const resultContainer = document.getElementById('image-test-result');
        const displayContainer = document.getElementById('image-display');
        
        // Clear previous results
        resultContainer.innerHTML = '';
        displayContainer.innerHTML = '';
        
        // Add loading indicator
        const loadingSpinner = document.createElement('div');
        loadingSpinner.className = 'loading-spinner';
        displayContainer.appendChild(loadingSpinner);
        
        // Create image element
        const img = new Image();
        
        // Set up load handlers
        img.onload = function() {
            // Remove loading indicator
            displayContainer.innerHTML = '';
            
            // Display the image
            img.className = 'test-image';
            displayContainer.appendChild(img);
            
            // Show success message
            const status = document.createElement('div');
            status.className = 'image-load-status success';
            status.textContent = `Image loaded successfully: ${img.width}x${img.height}px`;
            resultContainer.appendChild(status);
            
            // Add debug controls
            const controls = document.createElement('div');
            controls.className = 'debug-image-controls';
            controls.innerHTML = `
                <button class="reload-btn">Reload Image</button>
                <button class="test-in-sprite">Test in Animation</button>
            `;
            resultContainer.appendChild(controls);
            
            // Add reload button handler
            controls.querySelector('.reload-btn').addEventListener('click', () => {
                img.src = path + '?t=' + Date.now(); // Force reload
            });
            
            DebugSystem.success(`Image loaded successfully: ${path}`);
        };
        
        img.onerror = function() {
            // Remove loading indicator
            displayContainer.innerHTML = '';
            
            // Show error message
            const errorMsg = document.createElement('div');
            errorMsg.textContent = 'Failed to load image';
            errorMsg.style.color = '#e67e73';
            displayContainer.appendChild(errorMsg);
            
            // Show status
            const status = document.createElement('div');
            status.className = 'image-load-status error';
            status.textContent = `Failed to load image from: ${path}`;
            resultContainer.appendChild(status);
            
            // Add retry button
            const retryBtn = document.createElement('button');
            retryBtn.textContent = 'Retry';
            retryBtn.className = 'primary';
            retryBtn.style.marginTop = '10px';
            retryBtn.addEventListener('click', () => {
                // Retry loading with cache buster
                UIController._testImageLoading(path + '?t=' + Date.now());
            });
            resultContainer.appendChild(retryBtn);
            
            DebugSystem.error(`Failed to load image: ${path}`);
        };
        
        // Set source to trigger loading
        img.src = path;
    },
    
    // Debounce helper for input handling
    _debounce: function(func, wait) {
        let timeout;
        
        return function() {
            const context = this;
            const args = arguments;
            
            const later = function() {
                timeout = null;
                func.apply(context, args);
            };
            
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
};

// Initialize systems on page load
document.addEventListener('DOMContentLoaded', function() {
    // Initialize systems in sequence
    DebugSystem.initialize();
    AnimationSystem.initialize();
    UIController.initialize();
    
    DebugSystem.success("Character Animation Tester initialized");
});
</script>
</body>
</html>