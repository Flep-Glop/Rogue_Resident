<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Character Animation Tester</title>
    <style>
        /* Base styles */
        body {
            background-color: #121218;
            color: #ffffff;
            font-family: Arial, sans-serif;
            padding: 20px;
            margin: 0;
        }
        
        .test-container {
            max-width: 950px;
            margin: 20px auto;
            padding: 20px;
            background-color: #1e1e2a;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #5b8dd9;
            font-size: 28px;
        }
        
        /* Character selection panel */
        .character-select-panel {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #292936;
            border-radius: 8px;
            border: 1px solid #3d4c60;
        }
        
        .character-button {
            padding: 8px 15px;
            background-color: #3d4c60;
            border: 2px solid transparent;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .character-button:hover {
            background-color: #4a5d75;
            transform: translateY(-2px);
        }
        
        .character-button.active {
            border-color: #5b8dd9;
            background-color: #4a5d75;
            box-shadow: 0 0 10px rgba(91, 141, 217, 0.5);
        }
        
        /* Character display area */
        .character-display {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            gap: 20px;
        }
        
        .character-view {
            width: 320px;
            padding: 15px;
            border: 2px solid #5b8dd9;
            border-radius: 8px;
            background-color: #292936;
        }
        
        .stats-view {
            width: 260px;
            padding: 15px;
            border: 2px solid #56b886;
            border-radius: 8px;
            background-color: #292936;
            display: flex;
            flex-direction: column;
        }
        
        .character-details {
            text-align: center;
        }
        
        .character-name {
            margin-bottom: 10px;
            color: #5b8dd9;
            font-size: 18px;
            font-weight: bold;
        }
        
        .character-avatar-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 auto;
            position: relative;
            width: 100%;
            text-align: center;
        }
        
        .character-avatar {
            width: 120px;
            height: 120px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            margin: 15px auto;
        }
        
        .character-sprite-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }
        
        .character-sprite-container.wide-sprite {
            width: auto !important;
            max-width: none !important;
            transform-origin: center center;
            z-index: 10;
        }
        
        .character-avatar.ability-mode {
            overflow: visible !important;
            z-index: 10;
        }
        
        .character-sprite {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            transform-origin: center center !important;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
        }
        
        /* Animation controls */
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        .control-panel {
            background-color: #292936;
            border: 1px solid #3d4c60;
            border-radius: 8px;
            padding: 15px;
        }
        
        .control-panel h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #d4dae0;
            text-align: center;
            font-size: 16px;
            border-bottom: 1px solid #3d4c60;
            padding-bottom: 8px;
        }
        
        .button-group {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        button {
            background-color: #3d4c60;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        button:hover {
            background-color: #4a5d75;
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.primary {
            background-color: #5b8dd9;
        }
        
        button.primary:hover {
            background-color: #4a7bc7;
        }
        
        button.success {
            background-color: #56b886;
        }
        
        button.success:hover {
            background-color: #45a275;
        }
        
        button.danger {
            background-color: #e67e73;
        }
        
        button.danger:hover {
            background-color: #d56c62;
        }
        
        button.special {
            background-color: #d35db3;
            padding: 10px 15px;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(211, 93, 179, 0.3);
        }
        
        button.special:hover {
            background-color: #c14da2;
            box-shadow: 0 0 15px rgba(211, 93, 179, 0.5);
        }
        
        /* Debug tools section */
        .range-control {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .range-control label {
            width: 100px;
            font-size: 14px;
        }
        
        .range-control input {
            flex: 1;
        }
        
        .range-value {
            width: 50px;
            text-align: center;
            font-size: 14px;
            color: #5b8dd9;
        }
        
        /* Debug log and visualization */
        .debug-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        .debug-panel {
            background-color: #292936;
            border: 1px solid #3d4c60;
            border-radius: 8px;
            padding: 15px;
        }
        
        .debug-panel h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #d4dae0;
            text-align: center;
            font-size: 16px;
            border-bottom: 1px solid #3d4c60;
            padding-bottom: 8px;
        }
        
        .debug-log {
            height: 200px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        
        .debug-log p {
            margin: 5px 0;
            color: #a7adb5;
        }
        
        .debug-log p.info {
            color: #5b8dd9;
        }
        
        .debug-log p.success {
            color: #56b886;
        }
        
        .debug-log p.error {
            color: #e67e73;
        }
        
        .debug-log p.warning {
            color: #f0c866;
        }
        
        .debug-visualizer {
            height: 200px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }
        
        .frame-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            color: #5b8dd9;
            font-family: monospace;
        }
        
        .frame-timeline {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 30px;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            padding: 5px;
            box-sizing: border-box;
        }
        
        .frame-marker {
            flex: 1;
            height: 100%;
            background-color: #3d4c60;
            margin: 0 1px;
            transition: background-color 0.2s;
        }
        
        .frame-marker.active {
            background-color: #5b8dd9;
        }
        
        /* Animation for ability activation */
        .ability-flash {
            animation: ability-flash 0.5s ease-in-out;
        }
        
        @keyframes ability-flash {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5) saturate(1.5); }
            100% { filter: brightness(1); }
        }
        
        /* Debug grid to help visualize sprite positioning */
        .debug-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            border: 1px dashed rgba(255, 255, 255, 0.3);
            z-index: 5;
            display: none;
        }
        
        .debug-grid::before, .debug-grid::after {
            content: '';
            position: absolute;
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .debug-grid::before {
            top: 0;
            bottom: 0;
            left: 50%;
            width: 1px;
            transform: translateX(-0.5px);
        }
        
        .debug-grid::after {
            left: 0;
            right: 0;
            top: 50%;
            height: 1px;
            transform: translateY(-0.5px);
        }
        
        .show-grid .debug-grid {
            display: block;
        }
        
        /* Character statistics visualization */
        .character-stat {
            margin-bottom: 12px;
        }
        
        .stat-label {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .stat-name {
            color: #d4dae0;
        }
        
        .stat-value {
            color: #5b8dd9;
            font-weight: bold;
        }
        
        .stat-bar {
            height: 8px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .stat-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .stat-fill.lives {
            background-color: #e67e73;
        }
        
        .stat-fill.insight {
            background-color: #5b8dd9;
        }
        
        .stat-fill.level {
            background-color: #f0c866;
        }
        
        .special-ability {
            margin-top: auto;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }
        
        .ability-header {
            font-size: 14px;
            color: #f0c866;
            margin-bottom: 5px;
        }
        
        .ability-description {
            font-size: 12px;
            color: #d4dae0;
            line-height: 1.4;
        }
        
        /* Animation States Section */
        .animation-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }
        
        .animation-info div {
            display: flex;
            flex-direction: column;
        }
        
        .info-label {
            font-size: 12px;
            color: #a7adb5;
        }
        
        .info-value {
            font-size: 14px;
            color: #5b8dd9;
            font-weight: bold;
        }
        
        /* Function test panel */
        .function-test-panel {
            margin-top: 20px;
            background-color: #292936;
            border: 1px solid #3d4c60;
            border-radius: 8px;
            padding: 15px;
        }
        
        .function-test-panel h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #d4dae0;
            text-align: center;
            font-size: 16px;
            border-bottom: 1px solid #3d4c60;
            padding-bottom: 8px;
        }
        
        .function-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .function-result {
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Advanced Character Animation Tester</h1>
        
        <!-- Character Selection -->
        <div class="character-select-panel">
            <button class="character-button active" data-character="resident">Resident</button>
            <button class="character-button" data-character="physicist">Physicist</button>
            <button class="character-button" data-character="qa_specialist">QA Specialist</button>
            <button class="character-button" data-character="debug_mode">Debug Mode</button>
        </div>
        
        <!-- Character Display -->
        <div class="character-display">
            <div class="character-view">
                <div class="character-details">
                    <p class="character-name" id="character-name">Medical Physics Resident</p>
                    <div class="character-avatar-container">
                        <div class="character-avatar" id="character-avatar">
                            <div id="character-sprite-container"></div>
                            <div class="debug-grid"></div>
                        </div>
                    </div>
                    
                    <!-- Animation Info -->
                    <div class="animation-info">
                        <div>
                            <span class="info-label">Current Animation</span>
                            <span class="info-value" id="current-animation">idle</span>
                        </div>
                        <div>
                            <span class="info-label">Frame</span>
                            <span class="info-value" id="current-frame">1</span>
                        </div>
                        <div>
                            <span class="info-label">State</span>
                            <span class="info-value" id="animation-state">playing</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Character Stats -->
            <div class="stats-view">
                <div class="character-stat">
                    <div class="stat-label">
                        <span class="stat-name">Lives</span>
                        <span class="stat-value" id="lives-stat">3/3</span>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-fill lives" style="width: 100%"></div>
                    </div>
                </div>
                
                <div class="character-stat">
                    <div class="stat-label">
                        <span class="stat-name">Insight</span>
                        <span class="stat-value" id="insight-stat">20</span>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-fill insight" style="width: 20%"></div>
                    </div>
                </div>
                
                <div class="character-stat">
                    <div class="stat-label">
                        <span class="stat-name">Level</span>
                        <span class="stat-value" id="level-stat">1</span>
                    </div>
                    <div class="stat-bar">
                        <div class="stat-fill level" style="width: 10%"></div>
                    </div>
                </div>
                
                <div class="special-ability">
                    <div class="ability-header" id="ability-name">Literature Review</div>
                    <div class="ability-description" id="ability-description">
                        Once per floor, can skip a question node without penalty.
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Control Panels -->
        <div class="controls">
            <!-- Basic Animation Controls -->
            <div class="control-panel">
                <h3>Animation Controls</h3>
                <div class="button-group">
                    <button id="btn-idle" class="primary">Idle</button>
                    <button id="btn-walk">Walk</button>
                    <button id="btn-ability">Regular Ability</button>
                    <button id="btn-special-ability" class="special">Special Ability</button>
                </div>
                
                <div class="button-group">
                    <button id="btn-play" class="success">Play</button>
                    <button id="btn-pause">Pause</button>
                    <button id="btn-stop" class="danger">Stop</button>
                    <button id="btn-reset">Reset</button>
                </div>
            </div>
            
            <!-- Debug Tools -->
            <div class="control-panel">
                <h3>Debug Tools</h3>
                
                <div class="range-control">
                    <label for="scale-range">Scale:</label>
                    <input type="range" id="scale-range" min="1" max="5" step="0.5" value="3">
                    <span class="range-value" id="scale-value">3.0</span>
                </div>
                
                <div class="range-control">
                    <label for="speed-range">Speed:</label>
                    <input type="range" id="speed-range" min="50" max="500" step="10" value="200">
                    <span class="range-value" id="speed-value">200ms</span>
                </div>
                
                <div class="button-group">
                    <button id="btn-toggle-grid">Toggle Grid</button>
                    <button id="btn-toggle-overflow">Toggle Overflow</button>
                    <button id="btn-toggle-loop">Toggle Looping</button>
                    <button id="btn-toggle-wide">Toggle Wide Mode</button>
                </div>
            </div>
        </div>
        
        <!-- Debug Section -->
        <div class="debug-section">
            <!-- Debug Log -->
            <div class="debug-panel">
                <h3>Debug Log</h3>
                <div class="debug-log" id="debug-log">
                    <p>Animation debug log:</p>
                </div>
            </div>
            
            <!-- Animation Visualizer -->
            <div class="debug-panel">
                <h3>Animation Visualizer</h3>
                <div class="debug-visualizer">
                    <div class="frame-counter" id="frame-counter">Frame: 1/4</div>
                    <div class="frame-timeline" id="frame-timeline">
                        <!-- Frame markers will be added dynamically -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Function Testing Panel -->
        <div class="function-test-panel">
            <h3>Function Testing</h3>
            <div class="function-buttons">
                <button id="test-get-character">Test getCharacter()</button>
                <button id="test-get-animations">Test getCharacterAnimations()</button>
                <button id="test-animation-data">Test getCharacterAnimation()</button>
                <button id="test-create-anim">Test createAnimation()</button>
                <button id="test-play-anim">Test playAnimation()</button>
                <button id="test-ability-anim">Test playAbilityAnimation()</button>
            </div>
            <div class="function-result" id="function-result">
                <p>Function test results will appear here.</p>
            </div>
        </div>
    </div>
    
    <script>
        // Simulated Character Assets (full implementation would be imported)
        window.CharacterAssets = {
            characters: {
                resident: {
                    name: "Resident",
                    description: "A new medical physics resident.",
                    imagePath: "/static/img/characters/resident/idle.png",
                    spritePath: "/static/img/characters/resident/",
                    animations: {
                        idle: {
                            file: "idle.png", 
                            frames: 1
                        },
                        walking: {
                            file: "walking.png", 
                            frames: 4, 
                            speed: 250
                        },
                        ability: {
                            file: "ability.png", 
                            frames: 6, 
                            speed: 120
                        },
                        specialAbility: {
                            file: "special_ability.png", 
                            frames: 10, 
                            speed: 80,
                            aspectRatio: 2.5 // Wider sprite
                        }
                    },
                    stats: {
                        startingInsight: 20,
                        startingLives: 3,
                        maxLives: 3,
                        level: 1
                    },
                    special_ability: {
                        name: "Literature Review",
                        description: "Once per floor, can skip a question node without penalty.",
                        uses_per_floor: 1
                    }
                },
                physicist: {
                    name: "Junior Physicist",
                    description: "More experienced with treatment planning but fewer lives.",
                    imagePath: "/static/img/characters/physicist/portrait.png",
                    spritePath: "/static/img/characters/physicist/",
                    animations: {
                        idle: {
                            file: "idle.png", 
                            frames: 1
                        },
                        walking: {
                            file: "walking.png", 
                            frames: 4, 
                            speed: 250
                        },
                        ability: {
                            file: "ability.png", 
                            frames: 6, 
                            speed: 120
                        },
                        specialAbility: {
                            file: "special_ability.png", 
                            frames: 10, 
                            speed: 80,
                            aspectRatio: 2.5
                        }
                    },
                    stats: {
                        startingInsight: 30,
                        startingLives: 2,
                        maxLives: 2,
                        level: 1
                    },
                    special_ability: {
                        name: "Peer Review",
                        description: "Can see the correct answer for one question per floor.",
                        uses_per_floor: 1
                    }
                },
                qa_specialist: {
                    name: "QA Specialist",
                    description: "Quality Assurance expert with deep knowledge of machine checks.",
                    imagePath: "/static/img/characters/qa_specialist/portrait.png",
                    spritePath: "/static/img/characters/qa_specialist/",
                    animations: {
                        idle: {
                            file: "idle.png", 
                            frames: 1
                        },
                        walking: {
                            file: "walking.png", 
                            frames: 4, 
                            speed: 250
                        },
                        ability: {
                            file: "ability.png", 
                            frames: 6, 
                            speed: 120
                        },
                        specialAbility: {
                            file: "special_ability.png", 
                            frames: 10, 
                            speed: 80,
                            aspectRatio: 2.5
                        }
                    },
                    stats: {
                        startingInsight: 25,
                        startingLives: 3,
                        maxLives: 3,
                        level: 1
                    },
                    special_ability: {
                        name: "Measurement Uncertainty",
                        description: "Can retry one failed question per floor.",
                        uses_per_floor: 1
                    }
                },
                debug_mode: {
                    name: "Debug Physicist",
                    description: "A special character with godlike powers for testing purposes.",
                    imagePath: "/static/img/characters/debug_mode/portrait.png",
                    spritePath: "/static/img/characters/debug_mode/",
                    animations: {
                        idle: {
                            file: "idle.png", 
                            frames: 1
                        },
                        walking: {
                            file: "walking.png", 
                            frames: 4, 
                            speed: 250
                        },
                        ability: {
                            file: "ability.png", 
                            frames: 6, 
                            speed: 120
                        },
                        specialAbility: {
                            file: "special_ability.png", 
                            frames: 10, 
                            speed: 80,
                            aspectRatio: 2.5
                        }
                    },
                    stats: {
                        startingInsight: 999,
                        startingLives: 99,
                        maxLives: 99,
                        level: 42
                    },
                    special_ability: {
                        name: "Debug Override",
                        description: "Can instantly complete any node without penalties.",
                        uses_per_floor: 999
                    }
                }
            },
            
            // Helper methods
            getCharacterKeys: function() {
                return Object.keys(this.characters);
            },
            
            getCharacter: function(key) {
                return this.characters[key] || null;
            },
            
            getCharacterImagePath: function(key) {
                const character = this.getCharacter(key);
                return character ? character.imagePath : '/static/img/characters/resident/portrait.png';
            },
            
            getCharacterSpritePath: function(key, animation = "idle") {
                const character = this.getCharacter(key);
                if (!character || !character.animations || !character.animations[animation]) {
                    return null;
                }
                
                return character.spritePath + character.animations[animation].file;
            },
            
            getCharacterAnimation: function(key, animation = "idle") {
                const character = this.getCharacter(key);
                if (!character || !character.animations) return null;
                
                return character.animations[animation] || character.animations.idle;
            },
            
            getCharacterAnimations: function(key) {
                const character = this.getCharacter(key);
                if (!character || !character.animations) return [];
                
                return Object.keys(character.animations);
            },
            
            getCharacterIdFromName: function(name) {
                for (const id in this.characters) {
                    if (this.characters[id].name === name) {
                        return id;
                    }
                }
                return 'resident';
            },
            
            getCharacterNameFromId: function(id) {
                const character = this.getCharacter(id);
                return character ? character.name : "Medical Physics Resident";
            }
        };
        
        // Enhanced Character Animation System
        const CharacterAnimation = {
            // Track active animations
            activeAnimations: {},
            loopEnabled: true,
            
            // Initialize animation system
            initialize: function() {
                this.logDebug("Character Animation system initialized");
                
                // Set up frame timeline
                this.updateFrameTimeline(4); // Default to 4 frames
                
                return this;
            },
            
            // Create a new animation instance for a character
            createAnimation: function(characterId, containerId, options = {}) {
                if (!characterId || !containerId) {
                    this.logError("Missing required parameters for createAnimation");
                    return null;
                }
                
                // Get container element
                const container = document.getElementById(containerId);
                if (!container) {
                    this.logError(`Animation container not found: ${containerId}`);
                    return null;
                }
                
                // Clear any existing content
                container.innerHTML = '';
                
                // Default options
                const defaultOptions = {
                    initialAnimation: 'idle',
                    autoPlay: true,
                    loop: this.loopEnabled,
                    scale: 3,
                    centerImage: true,
                    adaptiveWidth: false
                };
                
                // Merge defaults with provided options
                const animOptions = {...defaultOptions, ...options};
                
                // Create animation container element
                const animationContainer = document.createElement('div');
                animationContainer.className = 'character-animation-container';
                animationContainer.style.position = 'relative';
                animationContainer.style.width = '100%';
                animationContainer.style.height = '100%';
                
                if (animOptions.centerImage) {
                    animationContainer.style.display = 'flex';
                    animationContainer.style.justifyContent = 'center';
                    animationContainer.style.alignItems = 'center';
                }
                
                container.appendChild(animationContainer);
                
                // Create animation ID
                const animationId = `anim_${characterId}_${containerId}_${Date.now()}`;
                
                // Create animation instance
                const animation = {
                    id: animationId,
                    characterId: characterId,
                    containerId: containerId,
                    container: animationContainer,
                    currentAnimation: null,
                    frameIndex: 0,
                    animationTimer: null,
                    options: animOptions,
                    isPlaying: false,
                    debug: {
                        lastFrameTime: 0,
                        frameCount: 0,
                        frameRate: 0
                    }
                };
                
                // Store in active animations
                this.activeAnimations[animationId] = animation;
                
                // Set initial animation
                if (animOptions.initialAnimation && animOptions.autoPlay) {
                    this.playAnimation(animationId, animOptions.initialAnimation);
                }
                
                this.logInfo(`Created animation ${animationId} for character ${characterId}`);
                
                return animationId;
            },
            
            // Play a specific animation for a character
            playAnimation: function(animationId, animationName = 'idle', loop = null) {
                const animation = this.activeAnimations[animationId];
                if (!animation) {
                    this.logError(`Animation not found: ${animationId}`);
                    return false;
                }
                
                // Stop any current animation
                this.stopAnimation(animationId);
                
                // Get animation data
                const animData = CharacterAssets.getCharacterAnimation(animation.characterId, animationName);
                if (!animData) {
                    this.logError(`Animation data not found for ${animationName}`);
                    return false;
                }
                
                // Save current animation name
                animation.currentAnimation = animationName;
                
                // Update animation info display
                document.getElementById('current-animation').textContent = animationName;
                document.getElementById('animation-state').textContent = 'playing';
                
                // Override loop behavior if specified
                if (loop !== null) {
                    animation.options.loop = loop;
                } else {
                    // Otherwise use global setting
                    animation.options.loop = this.loopEnabled;
                }
                
                // For testing, we'll use colored boxes instead of actual sprites
                this._setupMockSpriteAnimation(animation, animData);
                
                // Update frame timeline
                this.updateFrameTimeline(animData.frames);
                
                animation.isPlaying = true;
                this.logInfo(`Playing animation: ${animationName} (loop: ${animation.options.loop})`);
                
                return true;
            },
            
            // Set up mock sprite animation for testing
            _setupMockSpriteAnimation: function(animation, animData) {
                // Handle aspect ratio for wide sprites
                const aspectRatio = animData.aspectRatio || 1;
                
                // Create sprite container
                const spriteContainer = document.createElement('div');
                spriteContainer.className = 'character-sprite-container';
                if (animation.options.adaptiveWidth && aspectRatio !== 1) {
                    spriteContainer.classList.add('wide-sprite');
                }
                
                spriteContainer.style.width = '100%';
                spriteContainer.style.height = '100%';
                spriteContainer.style.position = 'relative';
                
                // For wide sprites, adjust container
                if (animation.options.adaptiveWidth && aspectRatio !== 1) {
                    spriteContainer.style.width = `${aspectRatio * 100}%`;
                    spriteContainer.style.left = `${(1 - aspectRatio) * 50}%`;
                }
                
                // Create sprite element - in testing, we use a colored div
                const sprite = document.createElement('div');
                sprite.className = 'character-sprite';
                sprite.dataset.animation = animation.currentAnimation;
                sprite.style.width = '100%';
                sprite.style.height = '100%';
                
                // In a real implementation, we'd set the background image
                // For testing, we're using a colored div with dimensions
                sprite.style.backgroundColor = this._getAnimationColor(animation.currentAnimation);
                
                // Set dimensions based on frames
                const frameWidth = 100 / animData.frames;
                sprite.style.width = `${frameWidth}%`;
                
                // Apply scale
                const scale = animation.options.scale || 1;
                animation.container.style.setProperty('--character-scale', scale);
                sprite.style.transform = `translate(-50%, -50%) scale(${scale})`;
                
                // For testing, show frame number
                const frameIndicator = document.createElement('div');
                frameIndicator.style.position = 'absolute';
                frameIndicator.style.top = '50%';
                frameIndicator.style.left = '50%';
                frameIndicator.style.transform = 'translate(-50%, -50%)';
                frameIndicator.style.color = 'white';
                frameIndicator.style.fontSize = '16px';
                frameIndicator.style.fontWeight = 'bold';
                frameIndicator.style.textShadow = '1px 1px 2px black';
                frameIndicator.textContent = '1';
                frameIndicator.id = 'frame-indicator';
                sprite.appendChild(frameIndicator);
                
                // Add sprite to container
                spriteContainer.appendChild(sprite);
                
                // Clear container and add sprite
                animation.container.innerHTML = '';
                animation.container.appendChild(spriteContainer);
                
                // Set up animation
                animation.frameIndex = 0;
                animation.sprite = sprite;
                animation.frameIndicator = frameIndicator;
                animation.frames = animData.frames;
                animation.frameSpeed = animData.speed || 200;
                animation.isLooping = animation.options.loop;
                
                // Add "wide-mode" class to parent avatar container for wide animations
                if (animation.options.adaptiveWidth && aspectRatio !== 1) {
                    const avatarContainer = document.getElementById('character-avatar');
                    if (avatarContainer) {
                        avatarContainer.classList.add('ability-mode');
                        animation.avatarContainer = avatarContainer;
                    }
                }
                
                // Update frame counter
                document.getElementById('current-frame').textContent = '1';
                document.getElementById('frame-counter').textContent = `Frame: 1/${animData.frames}`;
                
                // Start animation loop if more than 1 frame
                if (animData.frames > 1) {
                    this._advanceFrame(animation.id);
                    animation.animationTimer = setInterval(() => {
                        this._advanceFrame(animation.id);
                    }, animation.frameSpeed);
                }
            },
            
            // Advance to next frame in animation
            _advanceFrame: function(animationId) {
                const animation = this.activeAnimations[animationId];
                if (!animation || !animation.sprite || !animation.frames) return;
                
                // Increment frame
                animation.frameIndex = (animation.frameIndex + 1) % animation.frames;
                
                // Update frame indicator
                if (animation.frameIndicator) {
                    animation.frameIndicator.textContent = animation.frameIndex + 1;
                }
                
                // Update frame counter in UI
                document.getElementById('current-frame').textContent = (animation.frameIndex + 1).toString();
                document.getElementById('frame-counter').textContent = `Frame: ${animation.frameIndex + 1}/${animation.frames}`;
                
                // Update frame timeline
                this.updateActiveFrame(animation.frameIndex);
                
                // If we've reached the end and not looping, stop animation
                if (animation.frameIndex === animation.frames - 1 && !animation.isLooping) {
                    setTimeout(() => {
                        this.stopAnimation(animationId);
                        
                        // Signal animation complete
                        const event = new CustomEvent('animationComplete', {
                            detail: {
                                animationId: animationId,
                                animationName: animation.currentAnimation
                            }
                        });
                        document.dispatchEvent(event);
                        
                        // Clean up wide mode if needed
                        if (animation.avatarContainer) {
                            animation.avatarContainer.classList.remove('ability-mode');
                        }
                        
                        const container = document.querySelector(`#${animation.containerId} .character-sprite-container`);
                        if (container && container.classList.contains('wide-sprite')) {
                            container.classList.remove('wide-sprite');
                        }
                        
                        this.logSuccess(`Animation completed: ${animation.currentAnimation}`);
                        document.getElementById('animation-state').textContent = 'stopped';
                    }, animation.frameSpeed / 2);
                }
                
                // Calculate and display performance metrics
                const now = performance.now();
                if (animation.debug.lastFrameTime) {
                    const frameTime = now - animation.debug.lastFrameTime;
                    animation.debug.frameRate = 1000 / frameTime;
                }
                animation.debug.lastFrameTime = now;
                animation.debug.frameCount++;
            },
            
            // Stop an animation
            stopAnimation: function(animationId) {
                const animation = this.activeAnimations[animationId];
                if (!animation) return false;
                
                // Clear any running timer
                if (animation.animationTimer) {
                    clearInterval(animation.animationTimer);
                    animation.animationTimer = null;
                }
                
                animation.isPlaying = false;
                document.getElementById('animation-state').textContent = 'stopped';
                return true;
            },
            
            // Pause an animation
            pauseAnimation: function(animationId) {
                const animation = this.activeAnimations[animationId];
                if (!animation || !animation.animationTimer) return false;
                
                // Clear timer but don't reset state
                clearInterval(animation.animationTimer);
                animation.animationTimer = null;
                animation.isPlaying = false;
                
                document.getElementById('animation-state').textContent = 'paused';
                this.logInfo(`Paused animation: ${animation.currentAnimation}`);
                
                return true;
            },
            
            // Resume a paused animation
            resumeAnimation: function(animationId) {
                const animation = this.activeAnimations[animationId];
                if (!animation || animation.isPlaying) return false;
                
                // Get current animation data
                const animData = CharacterAssets.getCharacterAnimation(animation.characterId, animation.currentAnimation);
                if (!animData) return false;
                
                // Restart timer from current frame
                animation.animationTimer = setInterval(() => {
                    this._advanceFrame(animation.id);
                }, animation.frameSpeed);
                
                animation.isPlaying = true;
                document.getElementById('animation-state').textContent = 'playing';
                this.logInfo(`Resumed animation: ${animation.currentAnimation}`);
                
                return true;
            },
            
            // Reset animation to first frame
            resetAnimation: function(animationId) {
                const animation = this.activeAnimations[animationId];
                if (!animation) return false;
                
                // Reset to first frame
                animation.frameIndex = 0;
                
                // Update frame indicator
                if (animation.frameIndicator) {
                    animation.frameIndicator.textContent = '1';
                }
                
                // Update frame counters
                document.getElementById('current-frame').textContent = '1';
                document.getElementById('frame-counter').textContent = `Frame: 1/${animation.frames}`;
                this.updateActiveFrame(0);
                
                this.logInfo(`Reset animation: ${animation.currentAnimation}`);
                
                return true;
            },
            
            // Play ability animations
            playAbilityAnimation: function(animationId, abilityName, onCompleteCallback) {
                const animation = this.activeAnimations[animationId];
                if (!animation) return false;
                
                const animData = CharacterAssets.getCharacterAnimation(animation.characterId, abilityName);
                if (!animData) {
                    this.logError(`Ability animation not found: ${abilityName}`);
                    return false;
                }
                
                const listener = (event) => {
                    if (event.detail.animationId === animationId) {
                        document.removeEventListener('animationComplete', listener);
                        
                        // Return to idle
                        this.playAnimation(animationId, 'idle', true);
                        
                        if (onCompleteCallback && typeof onCompleteCallback === 'function') {
                            onCompleteCallback();
                        }
                    }
                };
                
                document.addEventListener('animationComplete', listener);
                
                // Enable wide mode for this animation if it has an aspect ratio
                animation.options.adaptiveWidth = !!animData.aspectRatio && animData.aspectRatio !== 1;
                
                // Play the animation non-looping
                this.playAnimation(animationId, abilityName, false);
                
                // Add flash effect to avatar
                const avatar = document.getElementById('character-avatar');
                if (avatar) {
                    avatar.classList.add('ability-flash');
                    setTimeout(() => {
                        avatar.classList.remove('ability-flash');
                    }, 500);
                }
                
                this.logInfo(`Playing ability animation: ${abilityName}`);
                
                return true;
            },
            
            // Set animation scale
            setAnimationScale: function(animationId, scale) {
                const animation = this.activeAnimations[animationId];
                if (!animation) return false;
                
                animation.options.scale = scale;
                
                // Update scale of current animation
                const elements = animation.container.querySelectorAll('.character-sprite');
                elements.forEach(el => {
                    el.style.transform = `translate(-50%, -50%) scale(${scale})`;
                });
                
                this.logInfo(`Scale set to: ${scale}`);
                return true;
            },
            
            // Set animation speed
            setAnimationSpeed: function(animationId, speed) {
                const animation = this.activeAnimations[animationId];
                if (!animation) return false;
                
                // Update speed
                animation.frameSpeed = speed;
                
                // If animation is playing, restart timer with new speed
                if (animation.isPlaying && animation.animationTimer) {
                    clearInterval(animation.animationTimer);
                    animation.animationTimer = setInterval(() => {
                        this._advanceFrame(animation.id);
                    }, animation.frameSpeed);
                }
                
                this.logInfo(`Speed set to: ${speed}ms`);
                return true;
            },
            
            // Toggle wide mode
            toggleWideMode: function(animationId) {
                const animation = this.activeAnimations[animationId];
                if (!animation) return false;
                
                animation.options.adaptiveWidth = !animation.options.adaptiveWidth;
                
                // Reapply current animation to update container
                const currentAnim = animation.currentAnimation;
                this.playAnimation(animationId, currentAnim);
                
                this.logInfo(`Wide mode ${animation.options.adaptiveWidth ? 'enabled' : 'disabled'}`);
                return true;
            },
            
            // Toggle global looping setting
            toggleLooping: function() {
                this.loopEnabled = !this.loopEnabled;
                
                // Update all active animations
                for (const animId in this.activeAnimations) {
                    const animation = this.activeAnimations[animId];
                    animation.options.loop = this.loopEnabled;
                    animation.isLooping = this.loopEnabled;
                }
                
                this.logInfo(`Looping ${this.loopEnabled ? 'enabled' : 'disabled'}`);
                return this.loopEnabled;
            },
            
            // Get a color for each animation type (for testing)
            _getAnimationColor: function(animationName) {
                switch(animationName) {
                    case 'idle': return '#5b8dd9';
                    case 'walking': return '#56b886';
                    case 'ability': return '#f0c866';
                    case 'specialAbility': return '#d35db3';
                    default: return '#888888';
                }
            },
            
            // Update frame timeline visualization
            updateFrameTimeline: function(frameCount) {
                const timeline = document.getElementById('frame-timeline');
                timeline.innerHTML = '';
                
                for (let i = 0; i < frameCount; i++) {
                    const marker = document.createElement('div');
                    marker.className = 'frame-marker';
                    marker.dataset.frameIndex = i;
                    
                    if (i === 0) {
                        marker.classList.add('active');
                    }
                    
                    timeline.appendChild(marker);
                }
            },
            
            // Update active frame in timeline
            updateActiveFrame: function(frameIndex) {
                const markers = document.querySelectorAll('.frame-marker');
                markers.forEach((marker, index) => {
                    if (index === frameIndex) {
                        marker.classList.add('active');
                    } else {
                        marker.classList.remove('active');
                    }
                });
            },
            
            // Debug logging functions
            logDebug: function(message) {
                console.log(message);
                this._addLogEntry(message);
            },
            
            logInfo: function(message) {
                console.info(message);
                this._addLogEntry(message, 'info');
            },
            
            logSuccess: function(message) {
                console.log('%c' + message, 'color: green');
                this._addLogEntry(message, 'success');
            },
            
            logError: function(message) {
                console.error(message);
                this._addLogEntry(message, 'error');
            },
            
            logWarning: function(message) {
                console.warn(message);
                this._addLogEntry(message, 'warning');
            },
            
            _addLogEntry: function(message, type = '') {
                const logContainer = document.getElementById('debug-log');
                if (!logContainer) return;
                
                const entry = document.createElement('p');
                if (type) entry.className = type;
                
                // Add timestamp
                const now = new Date();
                const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}.${now.getMilliseconds().toString().padStart(3, '0')}`;
                
                entry.textContent = `[${timestamp}] ${message}`;
                
                logContainer.appendChild(entry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }
        };
        
        // Global state
        let currentCharacterId = 'resident';
        let animationId = null;
        let currentScale = 3.0;
        let currentSpeed = 200;
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize animation system
            CharacterAnimation.initialize();
            
            // Set up character buttons
            document.querySelectorAll('.character-button').forEach(btn => {
                btn.addEventListener('click', function() {
                    const characterId = this.dataset.character;
                    changeCharacter(characterId);
                    
                    // Update active button
                    document.querySelectorAll('.character-button').forEach(b => {
                        b.classList.remove('active');
                    });
                    this.classList.add('active');
                });
            });
            
            // Load initial character
            loadCharacter('resident');
            
            // Set up animation buttons
            document.getElementById('btn-idle').addEventListener('click', function() {
                CharacterAnimation.playAnimation(animationId, 'idle', CharacterAnimation.loopEnabled);
            });
            
            document.getElementById('btn-walk').addEventListener('click', function() {
                CharacterAnimation.playAnimation(animationId, 'walking', CharacterAnimation.loopEnabled);
            });
            
            document.getElementById('btn-ability').addEventListener('click', function() {
                CharacterAnimation.playAbilityAnimation(animationId, 'ability', () => {
                    CharacterAnimation.logSuccess("Regular ability animation completed!");
                });
            });
            
            document.getElementById('btn-special-ability').addEventListener('click', function() {
                CharacterAnimation.playAbilityAnimation(animationId, 'specialAbility', () => {
                    CharacterAnimation.logSuccess("Special ability animation completed!");
                });
            });
            
            // Set up playback control buttons
            document.getElementById('btn-play').addEventListener('click', function() {
                if (animationId) {
                    CharacterAnimation.resumeAnimation(animationId);
                }
            });
            
            document.getElementById('btn-pause').addEventListener('click', function() {
                if (animationId) {
                    CharacterAnimation.pauseAnimation(animationId);
                }
            });
            
            document.getElementById('btn-stop').addEventListener('click', function() {
                if (animationId) {
                    CharacterAnimation.stopAnimation(animationId);
                }
            });
            
            document.getElementById('btn-reset').addEventListener('click', function() {
                if (animationId) {
                    CharacterAnimation.resetAnimation(animationId);
                }
            });
            
            // Set up debug buttons
            document.getElementById('btn-toggle-grid').addEventListener('click', function() {
                document.getElementById('character-avatar').classList.toggle('show-grid');
                CharacterAnimation.logInfo("Grid visibility toggled");
            });
            
            document.getElementById('btn-toggle-overflow').addEventListener('click', function() {
                const avatar = document.getElementById('character-avatar');
                if (avatar.style.overflow === 'visible') {
                    avatar.style.overflow = 'hidden';
                    CharacterAnimation.logInfo("Overflow set to: hidden");
                } else {
                    avatar.style.overflow = 'visible';
                    CharacterAnimation.logInfo("Overflow set to: visible");
                }
            });
            
            document.getElementById('btn-toggle-loop').addEventListener('click', function() {
                const looping = CharacterAnimation.toggleLooping();
                this.textContent = looping ? "Disable Looping" : "Enable Looping";
            });
            
            document.getElementById('btn-toggle-wide').addEventListener('click', function() {
                if (animationId) {
                    CharacterAnimation.toggleWideMode(animationId);
                }
            });
            
            // Set up scale slider
            const scaleRange = document.getElementById('scale-range');
            scaleRange.addEventListener('input', function() {
                currentScale = parseFloat(this.value);
                document.getElementById('scale-value').textContent = currentScale.toFixed(1);
                
                if (animationId) {
                    CharacterAnimation.setAnimationScale(animationId, currentScale);
                }
            });
            
            // Set up speed slider
            const speedRange = document.getElementById('speed-range');
            speedRange.addEventListener('input', function() {
                currentSpeed = parseInt(this.value);
                document.getElementById('speed-value').textContent = `${currentSpeed}ms`;
                
                if (animationId) {
                    CharacterAnimation.setAnimationSpeed(animationId, currentSpeed);
                }
            });
            
            // Set up function test buttons
            document.getElementById('test-get-character').addEventListener('click', function() {
                const result = CharacterAssets.getCharacter(currentCharacterId);
                displayFunctionResult('getCharacter', result);
            });
            
            document.getElementById('test-get-animations').addEventListener('click', function() {
                const result = CharacterAssets.getCharacterAnimations(currentCharacterId);
                displayFunctionResult('getCharacterAnimations', result);
            });
            
            document.getElementById('test-animation-data').addEventListener('click', function() {
                const result = CharacterAssets.getCharacterAnimation(currentCharacterId, 'walking');
                displayFunctionResult('getCharacterAnimation', result);
            });
            
            document.getElementById('test-create-anim').addEventListener('click', function() {
                const options = {
                    initialAnimation: 'idle',
                    autoPlay: true,
                    loop: true,
                    scale: currentScale,
                    centerImage: true
                };
                
                displayFunctionResult('createAnimation options', options);
            });
            
            document.getElementById('test-play-anim').addEventListener('click', function() {
                const args = {
                    animationId: animationId,
                    animationName: 'walking',
                    loop: true
                };
                
                displayFunctionResult('playAnimation args', args);
            });
            
            document.getElementById('test-ability-anim').addEventListener('click', function() {
                const args = {
                    animationId: animationId,
                    abilityName: 'specialAbility',
                    onCompleteCallback: '() => { /* Callback function */ }'
                };
                
                displayFunctionResult('playAbilityAnimation args', args);
            });
        });
        
        // Load a character
        function loadCharacter(characterId) {
            // Store current character ID
            currentCharacterId = characterId;
            
            // Get character data
            const character = CharacterAssets.getCharacter(characterId);
            if (!character) {
                CharacterAnimation.logError(`Character not found: ${characterId}`);
                return;
            }
            
            // Update character name
            document.getElementById('character-name').textContent = character.name;
            
            // Update character stats
            const stats = character.stats;
            document.getElementById('lives-stat').textContent = `${stats.startingLives}/${stats.maxLives}`;
            document.getElementById('insight-stat').textContent = stats.startingInsight;
            document.getElementById('level-stat').textContent = stats.level;
            
            // Update stat bars
            const livesFill = document.querySelector('.stat-fill.lives');
            livesFill.style.width = `${(stats.startingLives / stats.maxLives) * 100}%`;
            
            const insightFill = document.querySelector('.stat-fill.insight');
            insightFill.style.width = `${(stats.startingInsight / 100) * 100}%`;
            
            const levelFill = document.querySelector('.stat-fill.level');
            levelFill.style.width = `${(stats.level / 10) * 100}%`;
            
            // Update ability info
            document.getElementById('ability-name').textContent = character.special_ability.name;
            document.getElementById('ability-description').textContent = character.special_ability.description;
            
            // Create animation
            if (animationId) {
                // Destroy any existing animation
                CharacterAnimation.stopAnimation(animationId);
            }
            
            animationId = CharacterAnimation.createAnimation(
                characterId,
                'character-sprite-container',
                {
                    initialAnimation: 'idle',
                    autoPlay: true,
                    loop: true,
                    scale: currentScale,
                    centerImage: true
                }
            );
            
            CharacterAnimation.logSuccess(`Loaded character: ${character.name}`);
        }
        
        // Change character
        function changeCharacter(characterId) {
            loadCharacter(characterId);
        }
        
        // Display function test results
        function displayFunctionResult(functionName, result) {
            const resultContainer = document.getElementById('function-result');
            resultContainer.innerHTML = '';
            
            const header = document.createElement('p');
            header.textContent = `Result of ${functionName}:`;
            header.className = 'info';
            resultContainer.appendChild(header);
            
            const resultText = document.createElement('pre');
            resultText.textContent = JSON.stringify(result, null, 2);
            resultContainer.appendChild(resultText);
            
            CharacterAnimation.logInfo(`Tested function: ${functionName}`);
        }
    </script>
</body>
</html>