<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medical Physics Residency: The Roguelike Challenge</title>
    <link href="/static/css/main.css" rel="stylesheet">
</head>
<body>
    <div class="pixel-container">
        <!-- CRT and scanline effects -->
        <div class="scanlines"></div>
        <div class="crt-effect"></div>
        
        <!-- Game title -->
        <h1 class="game-title">Medical Physics<br>Residency</h1>
        <h2 class="subtitle">The Roguelike Challenge</h2>
        
        <!-- Main menu -->
        <div class="menu-container">
            <button class="retro-btn start" id="start-game">New Game</button>
            <button class="retro-btn" id="continue-game">Continue</button>
            <button class="retro-btn options" id="options">Options</button>
            <button class="retro-btn help" id="help">Help</button>
        </div>
        
        <!-- Decorative pixel elements -->
        <div id="pixel-decorations"></div>
        
        <!-- Footer -->
        <div class="footer">
            <p>v0.1.0 | Press SPACE to start</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Create pixel decorations
            createPixelDecorations();
            
            // Button sound effect
            function playButtonSound() {
                // When we add audio files, we'll uncomment this
                // const sound = new Audio('/static/audio/click.mp3');
                // sound.volume = 0.3;
                // sound.play();
            }
            
            // IMPORTANT: Make sure these event listeners are preserved!
            document.getElementById('start-game').addEventListener('click', function() {
                playButtonSound();
                window.location.href = '/character-select'; 
            });
            
            document.getElementById('continue-game').addEventListener('click', function() {
                playButtonSound();
                // For now just redirect to game
                window.location.href = '/game';
            });
            
            document.getElementById('options').addEventListener('click', function() {
                playButtonSound();
                alert('Options will be available in the next update!');
            });
            
            document.getElementById('help').addEventListener('click', function() {
                playButtonSound();
                alert('Welcome to Medical Physics Residency! Navigate through each floor, answer questions correctly to gain insight, and avoid losing all your lives. Good luck!');
            });
            
            // Keyboard controls
            document.addEventListener('keydown', function(event) {
                if (event.code === 'Space') {
                    playButtonSound();
                    window.location.href = '/game';
                }
            });
        });
        
        function createPixelDecorations() {
            const decorationContainer = document.getElementById('pixel-decorations');
            if (!decorationContainer) return;
            
            // Clear existing decorations
            decorationContainer.innerHTML = '';
            
            // Color palette based on the screenshot - primarily blues with some accent colors
            const colors = [
                '#5b8dd9', // primary blue (brighter)
                '#3a5d99', // medium blue
                '#8be8e5', // cyan accent (for rare shapes)
                '#a7a1db', // purple accent (for rare shapes)
            ];
            
            // Create a grid background first if it doesn't exist
            if (!document.getElementById('grid-background')) {
                const gridBg = document.createElement('div');
                gridBg.id = 'grid-background';
                gridBg.style.position = 'absolute';
                gridBg.style.top = '0';
                gridBg.style.left = '0';
                gridBg.style.width = '100%';
                gridBg.style.height = '100%';
                gridBg.style.backgroundImage = 'linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px)';
                gridBg.style.backgroundSize = '20px 20px';
                gridBg.style.pointerEvents = 'none';
                gridBg.style.zIndex = '-1';
                document.querySelector('.pixel-container').insertBefore(gridBg, decorationContainer);
            }
            
            // Create mostly outlined squares and circles as seen in the image
            const shapeCount = 30; // Fewer, more deliberate shapes
            
            for (let i = 0; i < shapeCount; i++) {
                const decoration = document.createElement('div');
                decoration.classList.add('pixel-decoration');
                
                // More evenly distributed positions
                const x = 5 + Math.random() * 90; // Keep away from extreme edges
                const y = 5 + Math.random() * 90;
                
                // Size variations (slightly larger than before to match the image)
                const size = 10 + Math.floor(Math.random() * 25);
                
                // Colors from palette, with outline being more common
                const colorIndex = Math.floor(Math.random() * colors.length);
                const color = colors[colorIndex];
                
                // Almost all shapes should be outlines based on the image
                const hasOutlineOnly = Math.random() > 0.15; // 85% chance of outline
                
                // Apply base styles
                decoration.style.left = `${x}vw`;
                decoration.style.top = `${y}vh`;
                decoration.style.width = `${size}px`;
                decoration.style.height = `${size}px`;
                
                if (hasOutlineOnly) {
                    decoration.style.backgroundColor = 'transparent';
                    decoration.style.border = `1px solid ${color}`;
                    decoration.style.boxShadow = `0 0 2px ${color}`;
                } else {
                    decoration.style.backgroundColor = color;
                    decoration.style.opacity = '0.3'; // Make filled shapes subtle
                }
                
                // Based on the image, mostly squares and circles
                const shapeType = Math.random() > 0.3 ? 'square' : 'circle';
                
                if (shapeType === 'circle') {
                    decoration.style.borderRadius = '50%';
                }
                
                // Small dots (like stars in the background)
                if (Math.random() > 0.7) {
                    decoration.style.width = '2px';
                    decoration.style.height = '2px';
                    decoration.style.backgroundColor = '#ffffff';
                    decoration.style.border = 'none';
                    decoration.style.opacity = '0.5';
                }
                
                // Slow, subtle animations that match the floating feel in the image
                const animationType = Math.random();
                
                if (animationType < 0.4) {
                    // Very slow floating
                    const floatDuration = 20 + Math.random() * 40;
                    decoration.style.animation = `pixel-float ${floatDuration}s infinite ease-in-out`;
                } 
                else if (animationType < 0.8) {
                    // Slow rotation + subtle float for some squares
                    decoration.style.animation = `slow-rotate ${30 + Math.random() * 60}s linear infinite, pixel-float ${35 + Math.random() * 25}s infinite ease-in-out`;
                }
                else {
                    // Just stay in place with slight twinkle
                    decoration.style.animation = `pixel-twinkle ${15 + Math.random() * 25}s infinite ease-in-out`;
                }
                
                decorationContainer.appendChild(decoration);
            }
        }

        // Refresh occasionally but not too often
        setInterval(createPixelDecorations, 120000); // Every 2 minutes
    </script>
</body>
</html>