<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medical Physics Residency: The Roguelike Challenge</title>
    <link href="/static/css/main.css" rel="stylesheet">
</head>
<body>
    <div class="pixel-container">
        <!-- CRT and scanline effects -->
        <div class="scanlines"></div>
        <div class="crt-effect"></div>
        
        <!-- Game title -->
        <h1 class="game-title">Medical Physics<br>Residency</h1>
        <h2 class="subtitle">The Roguelike Challenge</h2>
        
        <!-- Main menu -->
        <div class="menu-container">
            <button class="retro-btn start" id="start-game">New Game</button>
            <button class="retro-btn" id="continue-game">Continue</button>
            <button class="retro-btn options" id="options">Options</button>
            <button class="retro-btn help" id="help">Help</button>
        </div>
        
        <!-- Decorative pixel elements -->
        <div id="pixel-decorations"></div>
        
        <!-- Footer -->
        <div class="footer">
            <p>v0.1.0 | Press SPACE to start</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Create pixel decorations
            createPixelDecorations();
            
            // Button sound effect
            function playButtonSound() {
                // When we add audio files, we'll uncomment this
                // const sound = new Audio('/static/audio/click.mp3');
                // sound.volume = 0.3;
                // sound.play();
            }
            
            // IMPORTANT: Make sure these event listeners are preserved!
            document.getElementById('start-game').addEventListener('click', function() {
                playButtonSound();
                window.location.href = '/character-select'; 
            });
            
            document.getElementById('continue-game').addEventListener('click', function() {
                playButtonSound();
                // For now just redirect to game
                window.location.href = '/game';
            });
            
            document.getElementById('options').addEventListener('click', function() {
                playButtonSound();
                alert('Options will be available in the next update!');
            });
            
            document.getElementById('help').addEventListener('click', function() {
                playButtonSound();
                alert('Welcome to Medical Physics Residency! Navigate through each floor, answer questions correctly to gain insight, and avoid losing all your lives. Good luck!');
            });
            
            // Keyboard controls
            document.addEventListener('keydown', function(event) {
                if (event.code === 'Space') {
                    playButtonSound();
                    window.location.href = '/game';
                }
            });
        });
        
        function createPixelDecorations() {
            const decorationContainer = document.getElementById('pixel-decorations');
            if (!decorationContainer) return;
            
            // Clear existing decorations
            decorationContainer.innerHTML = '';
            
            // Color palette that matches the game theme
            const colors = [
                '#5b8dd9', // primary
                '#56b886', // secondary
                '#e67e73', // danger
                '#f0c866', // warning
                '#9c77db', // purple
                '#5bbcd9'  // cyan
            ];
            
            // Different shape types
            const shapeTypes = ['square', 'circle', 'triangle', 'diamond', 'plus'];
            
            // Create a variety of shapes with different behaviors
            const shapeCount = 100; // Total number of shapes
            
            for (let i = 0; i < shapeCount; i++) {
                const decoration = document.createElement('div');
                decoration.classList.add('pixel-decoration');
                
                // Random position across the screen
                const x = Math.random() * 100;
                const y = Math.random() * 100;
                
                // Random size (keeping it pixel-like)
                const size = 4 + Math.floor(Math.random() * 8);
                
                // Random color from our palette
                const colorIndex = Math.floor(Math.random() * colors.length);
                const color = colors[colorIndex];
                
                // Randomly decide if this shape has fill or just outline
                const hasOutlineOnly = Math.random() > 0.6;
                
                // Apply base styles
                decoration.style.left = `${x}vw`;
                decoration.style.top = `${y}vh`;
                decoration.style.width = `${size}px`;
                decoration.style.height = `${size}px`;
                
                if (hasOutlineOnly) {
                    decoration.style.backgroundColor = 'transparent';
                    decoration.style.border = `2px solid ${color}`;
                } else {
                    decoration.style.backgroundColor = color;
                }
                
                // Choose a random shape type
                const shapeType = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];
                
                // Apply shape-specific styles
                switch (shapeType) {
                    case 'circle':
                        decoration.style.borderRadius = '50%';
                        break;
                    case 'triangle':
                        decoration.style.width = '0';
                        decoration.style.height = '0';
                        decoration.style.backgroundColor = 'transparent';
                        decoration.style.border = hasOutlineOnly 
                            ? `2px solid ${color}` 
                            : `${size}px solid transparent`;
                        decoration.style.borderBottomColor = hasOutlineOnly ? 'transparent' : color;
                        decoration.style.borderLeftWidth = `${size}px`;
                        decoration.style.borderRightWidth = `${size}px`;
                        decoration.style.borderBottomWidth = `${size * 1.5}px`;
                        break;
                    case 'diamond':
                        decoration.style.transform = 'rotate(45deg)';
                        break;
                    case 'plus':
                        if (!hasOutlineOnly) {
                            decoration.style.backgroundColor = 'transparent';
                            decoration.style.position = 'relative';
                            
                            // Create the plus shape with pseudo elements
                            decoration.style.overflow = 'visible';
                            decoration.innerHTML = `
                                <div style="position: absolute; background-color: ${color}; 
                                            width: 100%; height: 40%; left: 0; top: 30%"></div>
                                <div style="position: absolute; background-color: ${color}; 
                                            width: 40%; height: 100%; left: 30%; top: 0"></div>
                            `;
                        }
                        break;
                }
                
                // Choose a random animation type
                const animationType = Math.random();
                
                // Set different animation patterns
                if (animationType < 0.25) {
                    // Falling animation
                    const duration = 15 + Math.random() * 20;
                    const delay = Math.random() * 15;
                    decoration.style.animation = `pixel-fall ${duration}s linear ${delay}s infinite`;
                } 
                else if (animationType < 0.5) {
                    // Floating animation
                    const floatDuration = 8 + Math.random() * 12;
                    decoration.style.animation = `pixel-float ${floatDuration}s infinite ease-in-out`;
                }
                else if (animationType < 0.75) {
                    // Twinkling in place
                    const twinkleDuration = 4 + Math.random() * 8;
                    decoration.style.animation = `pixel-twinkle ${twinkleDuration}s infinite ease-in-out`;
                }
                else {
                    // Diagonal floating animation (new)
                    decoration.style.animation = `pixel-diagonal ${10 + Math.random() * 15}s infinite alternate`;
                }
                
                // Add additional random horizontal drift to some elements
                if (Math.random() > 0.7) {
                    decoration.style.animationName += ', pixel-drift';
                    decoration.style.animationDuration += `, ${20 + Math.random() * 20}s`;
                    decoration.style.animationIterationCount += ', infinite';
                    decoration.style.animationDirection += ', alternate';
                }
                
                decorationContainer.appendChild(decoration);
            }
        }

        // Add this to your setInterval to make the animation refresh periodically
        setInterval(createPixelDecorations, 60000); // Refresh every 60 seconds
    </script>
</body>
</html>