<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Animation Test</title>
    <style>
        :root {
            --primary: #5b8dd9;
            --secondary: #56b886;
            --danger: #e67e73;
            --warning: #f0c866;
            --background: #292b36;
            --background-alt: #21232d;
            --dark: #3d4c60;
            --text: #d4dae0;
        }
        
        body {
            background-color: var(--background);
            color: var(--text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1, h2, h3 {
            color: var(--primary);
        }
        
        .panel {
            background-color: var(--background-alt);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .test-area {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .test-card {
            background-color: var(--dark);
            border-radius: 8px;
            padding: 20px;
            min-width: 350px;
            flex: 1;
        }
        
        .character-select {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .character-btn {
            background-color: var(--background-alt);
            color: var(--text);
            border: 2px solid var(--primary);
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .character-btn:hover {
            background-color: var(--primary);
            color: white;
        }
        
        .character-btn.active {
            background-color: var(--primary);
            color: white;
        }
        
        .animation-select {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .animation-btn {
            background-color: var(--background-alt);
            color: var(--text);
            border: 2px solid var(--secondary);
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .animation-btn:hover {
            background-color: var(--secondary);
            color: white;
        }
        
        .animation-btn.active {
            background-color: var(--secondary);
            color: white;
        }
        
        .sprite-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            margin-bottom: 20px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            position: relative;
        }
        
        .sprite-display {
            width: 128px;
            height: 128px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .btn {
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:hover {
            filter: brightness(1.1);
        }
        
        .btn-secondary {
            background-color: var(--secondary);
        }
        
        .btn-danger {
            background-color: var(--danger);
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        .slider-container label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        input[type="range"] {
            width: 100%;
            background-color: var(--background-alt);
            height: 8px;
            border-radius: 4px;
            -webkit-appearance: none;
            appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background-color: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .sprite-info {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
            white-space: pre;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sprite Animation Test</h1>
        
        <div class="panel">
            <h2>Animation System Test</h2>
            <p>Use this page to test sprite animations for different characters and settings.</p>
            
            <div class="test-area">
                <div class="test-card">
                    <h3>Basic Animation Test</h3>
                    
                    <div class="character-select">
                        <button class="character-btn active" data-character="resident">Resident</button>
                        <button class="character-btn" data-character="physicist">Physicist</button>
                        <button class="character-btn" data-character="qa_specialist">QA Specialist</button>
                    </div>
                    
                    <div class="animation-select">
                        <button class="animation-btn active" data-animation="idle">Idle</button>
                        <button class="animation-btn" data-animation="walking">Walking</button>
                        <button class="animation-btn" data-animation="ability">Ability</button>
                        <button class="animation-btn" data-animation="specialAbility">Special</button>
                    </div>
                    
                    <div class="sprite-container">
                        <div id="sprite-display-1" class="sprite-display"></div>
                    </div>
                    
                    <div class="controls">
                        <button id="play-btn-1" class="btn">Play</button>
                        <button id="pause-btn-1" class="btn btn-secondary">Pause</button>
                        <button id="stop-btn-1" class="btn btn-danger">Stop</button>
                    </div>
                    
                    <div class="slider-container">
                        <label>
                            <span>Speed (FPS):</span>
                            <span id="fps-value-1">10</span>
                        </label>
                        <input type="range" id="fps-slider-1" min="1" max="30" value="10" step="1">
                    </div>
                    
                    <div class="slider-container">
                        <label>
                            <span>Scale:</span>
                            <span id="scale-value-1">3</span>
                        </label>
                        <input type="range" id="scale-slider-1" min="1" max="8" value="3" step="0.5">
                    </div>
                    
                    <div class="sprite-info" id="sprite-info-1">No animation loaded</div>
                </div>
                
                <div class="test-card">
                    <h3>Advanced Features Test</h3>
                    
                    <div class="character-select">
                        <button class="character-btn active" data-character="resident">Resident</button>
                        <button class="character-btn" data-character="physicist">Physicist</button>
                        <button class="character-btn" data-character="qa_specialist">QA Specialist</button>
                    </div>
                    
                    <div class="sprite-container">
                        <div id="sprite-display-2" class="sprite-display"></div>
                    </div>
                    
                    <div class="controls">
                        <button id="custom-seq-btn" class="btn">Custom Sequence</button>
                        <button id="reset-seq-btn" class="btn btn-secondary">Reset Sequence</button>
                        <button id="frame-by-frame-btn" class="btn">Frame-by-Frame</button>
                    </div>
                    
                    <div class="slider-container">
                        <label>
                            <span>Current Frame:</span>
                            <span id="frame-value">0</span>
                        </label>
                        <input type="range" id="frame-slider" min="0" value="0" step="1">
                    </div>
                    
                    <h4>Animation Events</h4>
                    <div class="sprite-info" id="event-log">Event log...</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Character Assets -->
    <script>
        // Mock CharacterAssets for testing
        window.CharacterAssets = {
            characters: {
                resident: {
                    name: "Resident",
                    description: "A new medical physics resident.",
                    imagePath: "/static/img/characters/resident/idle.png",
                    spritePath: "/static/img/characters/resident/",
                    animations: {
                        idle: {
                            file: "idle.png", 
                            frames: 11,
                            width: 97,    
                            height: 1188,  // Total height of all frames
                            speed: 150 
                        },
                        walking: {
                            file: "walking.png", 
                            frames: 4, 
                            width: 97,
                            height: 432,
                            speed: 250
                        },
                        ability: {
                            file: "ability.png", 
                            frames: 6, 
                            width: 97,
                            height: 648,
                            speed: 120
                        },
                        specialAbility: {
                            file: "special_ability.png", 
                            frames: 10, 
                            width: 242, // Wider sprite
                            height: 1080,
                            speed: 80,
                            offsetX: -72 // Center the wider sprite
                        }
                    }
                },
                physicist: {
                    name: "Physicist",
                    description: "A medical physicist.",
                    imagePath: "/static/img/characters/physicist/idle.png",
                    spritePath: "/static/img/characters/physicist/",
                    animations: {
                        idle: {
                            file: "idle.png", 
                            frames: 8,
                            width: 97,    
                            height: 864,
                            speed: 150 
                        },
                        walking: {
                            file: "walking.png", 
                            frames: 4, 
                            width: 97,
                            height: 432,
                            speed: 250
                        },
                        ability: {
                            file: "ability.png", 
                            frames: 6, 
                            width: 97,
                            height: 648,
                            speed: 120
                        },
                        specialAbility: {
                            file: "special_ability.png", 
                            frames: 10, 
                            width: 242,
                            height: 1080,
                            speed: 80,
                            offsetX: -72
                        }
                    }
                },
                qa_specialist: {
                    name: "QA Specialist",
                    description: "A QA specialist.",
                    imagePath: "/static/img/characters/qa_specialist/idle.png",
                    spritePath: "/static/img/characters/qa_specialist/",
                    animations: {
                        idle: {
                            file: "idle.png", 
                            frames: 8,
                            width: 97,    
                            height: 864,
                            speed: 150 
                        },
                        walking: {
                            file: "walking.png", 
                            frames: 4, 
                            width: 97,
                            height: 432,
                            speed: 250
                        },
                        ability: {
                            file: "ability.png", 
                            frames: 6, 
                            width: 97,
                            height: 648,
                            speed: 120
                        },
                        specialAbility: {
                            file: "special_ability.png", 
                            frames: 10, 
                            width: 242,
                            height: 1080,
                            speed: 80,
                            offsetX: -72
                        }
                    }
                }
            },
            
            getCharacter: function(id) {
                return this.characters[id] || null;
            },
            
            getCharacterKeys: function() {
                return Object.keys(this.characters);
            }
        };
    </script>
    
    <!-- Canvas Sprite Animator -->
    <script>
    /**
     * Canvas Sprite Animator
     * A robust, canvas-based sprite animation system optimized for pixel art
     * and retro-style game character animations.
     */
    class CanvasSpriteAnimator {
        /**
         * Create a new sprite animator
         * @param {Object} options Configuration options
         */
        constructor(options) {
          // Required options
          this.imagePath = options.imagePath;
          this.frameCount = options.frameCount || 1;
          this.frameWidth = options.frameWidth;
          this.frameHeight = options.frameHeight;
          
          // Optional settings
          this.fps = options.fps || 10;
          this.scale = options.scale || 1;
          this.loop = options.loop !== undefined ? options.loop : true;
          this.autoPlay = options.autoPlay !== undefined ? options.autoPlay : false;
          this.layout = options.layout || 'vertical';
          this.columns = options.columns || 1;
          this.rows = options.rows || 1;
          this.offsetX = options.offsetX || 0;
          this.offsetY = options.offsetY || 0;
          this.debug = options.debug || false;
          this.fallbackImagePath = options.fallbackImagePath || null;
          
          // Animation state
          this.currentFrame = 0;
          this.isPlaying = false;
          this.animationId = null;
          this.lastFrameTime = 0;
          this.frameDuration = 1000 / this.fps;
          
          // Image loading state
          this.imageLoadError = false;
          this.imageLoaded = false;
          this.fallbackLoaded = false;
          this.loadAttempted = false;
          
          // DOM elements
          this.container = null;
          this.canvas = null;
          this.ctx = null;
          
          // Event callbacks
          this.callbacks = {
            complete: [],
            framechange: [],
            error: []
          };
          
          // Custom animation sequence
          this.sequence = null;
          
          // Load sprite image
          this.loadSpriteImage();
        }
        
        /**
         * Load the sprite sheet image
         */
        loadSpriteImage() {
          this.loadAttempted = true;
          this.spriteImage = new Image();
          
          // Add load event handler
          this.spriteImage.onload = () => {
            this.imageLoaded = true;
            
            if (this.debug) {
              console.log(`Sprite image loaded: ${this.spriteImage.width}x${this.spriteImage.height}`);
            }
            
            // If we're already mounted, draw the first frame
            if (this.ctx) {
              this.drawFrame(this.currentFrame);
              
              // Auto-play if enabled
              if (this.autoPlay) {
                this.play();
              }
            }
          };
          
          // Add error handler
          this.spriteImage.onerror = (err) => {
            console.error(`Failed to load sprite image: ${this.imagePath}`, err);
            this.imageLoadError = true;
            
            // Trigger error callbacks
            this.triggerEvent('error', { error: err, path: this.imagePath });
            
            // Try fallback image if provided
            if (this.fallbackImagePath) {
              this.loadFallbackImage();
            } else {
              // Draw error placeholder if in debug mode
              if (this.ctx && this.debug) {
                this.drawErrorPlaceholder();
              }
            }
          };
          
          // Enable cross-origin if from another domain
          if (this.imagePath.startsWith('http') && 
              !this.imagePath.includes(window.location.hostname)) {
            this.spriteImage.crossOrigin = 'Anonymous';
          }
          
          // Set the source to start loading
          this.spriteImage.src = this.imagePath;
        }
        
        /**
         * Load fallback image if primary fails
         */
        loadFallbackImage() {
          const fallbackImage = new Image();
          
          fallbackImage.onload = () => {
            this.fallbackLoaded = true;
            this.spriteImage = fallbackImage;
            
            console.log(`Fallback image loaded: ${this.fallbackImagePath}`);
            
            // If we're already mounted, draw the first frame
            if (this.ctx) {
              this.drawFrame(this.currentFrame);
              
              // Auto-play if enabled
              if (this.autoPlay) {
                this.play();
              }
            }
          };
          
          fallbackImage.onerror = (err) => {
            console.error(`Failed to load fallback image: ${this.fallbackImagePath}`, err);
            
            // Draw error placeholder if in debug mode
            if (this.ctx && this.debug) {
              this.drawErrorPlaceholder();
            }
          };
          
          // Enable cross-origin if from another domain
          if (this.fallbackImagePath.startsWith('http') && 
              !this.fallbackImagePath.includes(window.location.hostname)) {
            fallbackImage.crossOrigin = 'Anonymous';
          }
          
          // Set the source to start loading
          fallbackImage.src = this.fallbackImagePath;
        }
        
        /**
         * Draw error placeholder when images fail
         */
        drawErrorPlaceholder() {
          if (!this.ctx) return;
          
          // Clear canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          
          // Draw checkerboard pattern
          const cellSize = 8 * this.scale;
          for (let y = 0; y < this.frameHeight * this.scale; y += cellSize) {
            for (let x = 0; x < this.frameWidth * this.scale; x += cellSize) {
              this.ctx.fillStyle = (Math.floor(x / cellSize) + Math.floor(y / cellSize)) % 2 === 0 
                ? 'rgba(255, 0, 255, 0.5)' 
                : 'rgba(0, 0, 0, 0.5)';
              this.ctx.fillRect(
                x + this.offsetX * this.scale, 
                y + this.offsetY * this.scale, 
                cellSize, 
                cellSize
              );
            }
          }
          
          // Draw error message
          this.ctx.fillStyle = '#FFFFFF';
          this.ctx.font = `${10 * this.scale}px monospace`;
          this.ctx.textAlign = 'center';
          this.ctx.fillText(
            'Image Error', 
            (this.frameWidth / 2 + this.offsetX) * this.scale, 
            (this.frameHeight / 2 + this.offsetY) * this.scale
          );
          
          // Draw frame dimensions
          this.ctx.font = `${8 * this.scale}px monospace`;
          this.ctx.fillText(
            `${this.frameWidth}x${this.frameHeight}`, 
            (this.frameWidth / 2 + this.offsetX) * this.scale, 
            (this.frameHeight / 2 + 15 + this.offsetY) * this.scale
          );
        }
        
        /**
         * Mount the animator to a DOM element
         * @param {HTMLElement|string} container Container element or selector
         * @returns {boolean} Success
         */
        mount(container) {
          // Get container element
          if (typeof container === 'string') {
            this.container = document.querySelector(container);
          } else {
            this.container = container;
          }
          
          if (!this.container) {
            console.error('Container element not found');
            return false;
          }
          
          // Clear any existing content
          this.container.innerHTML = '';
          
          // Set container styles
          this.container.style.width = `${this.frameWidth * this.scale}px`;
          this.container.style.height = `${this.frameHeight * this.scale}px`;
          this.container.style.position = 'relative';
          this.container.style.overflow = 'hidden';
          
          // Create canvas element
          this.canvas = document.createElement('canvas');
          this.canvas.width = this.frameWidth * this.scale;
          this.canvas.height = this.frameHeight * this.scale;
          this.canvas.style.display = 'block';
          this.canvas.style.imageRendering = 'pixelated';
          
          // Get 2D context
          this.ctx = this.canvas.getContext('2d');
          this.ctx.imageSmoothingEnabled = false; // Keep pixel art crisp
          
          // Add canvas to container
          this.container.appendChild(this.canvas);
          
          // Add debug overlay if needed
          if (this.debug) {
            this.createDebugOverlay();
          }
          
          // Handle image loading states
          if (this.imageLoadError && !this.fallbackLoaded) {
            // Draw error placeholder if in debug mode
            if (this.debug) {
              this.drawErrorPlaceholder();
            }
            return true;
          }
          
          // Check if image is already loaded
          if ((this.spriteImage && this.spriteImage.complete && !this.imageLoadError) || this.fallbackLoaded) {
            this.drawFrame(0);
            
            // Auto-play if enabled
            if (this.autoPlay) {
              this.play();
            }
          } else if (!this.loadAttempted) {
            // If we haven't tried loading yet, load the image
            this.loadSpriteImage();
          }
          
          return true;
        }
        
        /**
         * Create debug overlay
         * @private
         */
        createDebugOverlay() {
          const debugOverlay = document.createElement('div');
          debugOverlay.className = 'sprite-debug-overlay';
          debugOverlay.style.position = 'absolute';
          debugOverlay.style.bottom = '0';
          debugOverlay.style.left = '0';
          debugOverlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
          debugOverlay.style.color = 'white';
          debugOverlay.style.padding = '4px';
          debugOverlay.style.fontSize = '10px';
          debugOverlay.style.fontFamily = 'monospace';
          debugOverlay.style.pointerEvents = 'none';
          debugOverlay.style.zIndex = '100';
          debugOverlay.textContent = `Frame: 1/${this.frameCount}`;
          debugOverlay.id = 'debug-overlay-' + Date.now();
          this.container.appendChild(debugOverlay);
          
          // Add border to container
          this.container.style.border = '1px solid rgba(255,0,0,0.5)';
          
          // Store reference
          this.debugOverlay = debugOverlay;
        }
        
        /**
         * Update debug overlay
         * @private
         */
        updateDebugOverlay() {
          if (!this.debugOverlay) return;
          
          let status = this.imageLoadError ? 'ERROR' : (this.imageLoaded ? 'LOADED' : 'LOADING');
          
          this.debugOverlay.textContent = `Frame: ${this.currentFrame + 1}/${this.frameCount} | FPS: ${this.fps} | ${status}`;
          
          // Add image error indicator
          if (this.imageLoadError && !this.fallbackLoaded) {
            this.debugOverlay.style.backgroundColor = 'rgba(255,0,0,0.7)';
          } else if (this.fallbackLoaded) {
            this.debugOverlay.style.backgroundColor = 'rgba(255,165,0,0.7)';
          }
        }
        
        /**
         * Draw a specific frame
         * @param {number} frameIndex Frame to draw
         * @private
         */
        drawFrame(frameIndex) {
          if (!this.ctx) return;
          
          // Handle image loading errors
          if (this.imageLoadError && !this.fallbackLoaded) {
            if (this.debug) {
              this.drawErrorPlaceholder();
            }
            return;
          }
          
          // Make sure image is loaded and complete
          if (!this.spriteImage || !this.spriteImage.complete) return;
          
          // Store current frame
          this.currentFrame = frameIndex;
          
          // Clear canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          
          // Calculate source rectangle based on layout
          let sx, sy;
          
          switch(this.layout) {
            case 'horizontal':
              sx = frameIndex * this.frameWidth;
              sy = 0;
              break;
              
            case 'grid':
              sx = (frameIndex % this.columns) * this.frameWidth;
              sy = Math.floor(frameIndex / this.columns) * this.frameHeight;
              break;
              
            case 'vertical':
            default:
              sx = 0;
              sy = frameIndex * this.frameHeight;
              break;
          }
          
          // Calculate destination rectangle with offsets
          const dx = this.offsetX * this.scale;
          const dy = this.offsetY * this.scale;
          const dWidth = this.frameWidth * this.scale;
          const dHeight = this.frameHeight * this.scale;
          
          try {
            // Draw the frame
            this.ctx.drawImage(
              this.spriteImage,
              sx, sy, this.frameWidth, this.frameHeight,
              dx, dy, dWidth, dHeight
            );
          } catch (error) {
            console.error('Error drawing sprite frame:', error);
            this.imageLoadError = true;
            
            if (this.debug) {
              this.drawErrorPlaceholder();
            }
            
            return;
          }
          
          // Draw debug info if enabled
          if (this.debug) {
            this.drawDebugInfo();
            this.updateDebugOverlay();
          }
          
          // Trigger framechange event
          this.triggerEvent('framechange', { frame: frameIndex });
        }
        
        /**
         * Draw debug visualization
         * @private
         */
        drawDebugInfo() {
          // Draw frame border
          this.ctx.strokeStyle = 'rgba(255,0,0,0.5)';
          this.ctx.lineWidth = 1;
          this.ctx.strokeRect(
            this.offsetX * this.scale, 
            this.offsetY * this.scale, 
            this.frameWidth * this.scale, 
            this.frameHeight * this.scale
          );
          
          // Draw center point
          this.ctx.fillStyle = 'rgba(0,255,0,0.5)';
          this.ctx.beginPath();
          this.ctx.arc(
            (this.offsetX + this.frameWidth/2) * this.scale, 
            (this.offsetY + this.frameHeight/2) * this.scale, 
            3, 0, Math.PI * 2
          );
          this.ctx.fill();
        }
        
        /**
         * Animation loop
         * @param {number} timestamp Current time
         * @private
         */
        animationLoop(timestamp) {
          if (!this.isPlaying) return;
          
          // Handle image loading errors
          if (this.imageLoadError && !this.fallbackLoaded) {
            this.pause();
            return;
          }
          
          // Calculate time passed since last frame
          const elapsed = timestamp - this.lastFrameTime;
          
          // If enough time has passed, advance to next frame
          if (elapsed >= this.frameDuration) {
            // Update time tracking with adjustment to prevent drift
            this.lastFrameTime = timestamp - (elapsed % this.frameDuration);
            
            // Determine next frame
            let nextFrame;
            
            // If using custom sequence, use that
            if (this.sequence && this.sequence.length > 0) {
              const currentIndex = this.sequence.indexOf(this.currentFrame);
              const nextIndex = (currentIndex + 1) % this.sequence.length;
              nextFrame = this.sequence[nextIndex];
              
              // Check if we've reached the end and should stop
              if (nextIndex === 0 && !this.loop) {
                this.stop();
                this.triggerEvent('complete');
                return;
              }
            } else {
              // Standard sequential frames
              nextFrame = (this.currentFrame + 1) % this.frameCount;
              
              // Check if we've reached the end and should stop
              if (nextFrame === 0 && !this.loop) {
                this.stop();
                this.triggerEvent('complete');
                return;
              }
            }
            
            // Draw the new frame
            this.drawFrame(nextFrame);
          }
          
          // Continue animation loop
          this.animationId = requestAnimationFrame(this.animationLoop.bind(this));
        }
        
        /**
         * Start or resume animation
         */
        play() {
          // Don't play if there's an error and no fallback
          if (this.imageLoadError && !this.fallbackLoaded) {
            console.warn(`Cannot play animation with broken image: ${this.imagePath}`);
            return;
          }
          
          if (this.isPlaying) return;
          
          this.isPlaying = true;
          this.lastFrameTime = performance.now();
          this.animationId = requestAnimationFrame(this.animationLoop.bind(this));
          
          if (this.debug) {
            console.log('Animation started');
          }
        }
        
        /**
         * Pause animation
         */
        pause() {
          if (!this.isPlaying) return;
          
          this.isPlaying = false;
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }
          
          if (this.debug) {
            console.log('Animation paused');
          }
        }
        
        /**
         * Stop animation and reset to first frame
         */
        stop() {
          this.pause();
          this.currentFrame = 0;
          this.drawFrame(0);
          
          if (this.debug) {
            console.log('Animation stopped');
          }
        }
        
        /**
         * Go to a specific frame
         * @param {number} frameIndex Frame to display
         */
        goToFrame(frameIndex) {
          if (frameIndex < 0 || frameIndex >= this.frameCount) {
            console.error(`Invalid frame index: ${frameIndex}`);
            return;
          }
          
          // Pause and draw the specified frame
          this.pause();
          this.drawFrame(frameIndex);
        }
        
        /**
         * Set animation speed
         * @param {number} fps Frames per second
         */
        setSpeed(fps) {
          this.fps = fps;
          this.frameDuration = 1000 / fps;
          
          if (this.debug) {
            console.log(`Animation speed set to ${fps} fps`);
            this.updateDebugOverlay();
          }
        }
        
        /**
         * Set animation scale
         * @param {number} scale Scale factor
         */
        setScale(scale) {
          this.scale = scale;
          
          if (this.canvas) {
            // Update canvas size
            this.canvas.width = this.frameWidth * scale;
            this.canvas.height = this.frameHeight * scale;
            
            // Update container size
            this.container.style.width = `${this.frameWidth * scale}px`;
            this.container.style.height = `${this.frameHeight * scale}px`;
            
            // Re-disable image smoothing (gets reset when canvas is resized)
            this.ctx.imageSmoothingEnabled = false;
            
            // Redraw current frame
            this.drawFrame(this.currentFrame);
          }
          
          if (this.debug) {
            console.log(`Animation scale set to ${scale}x`);
          }
        }
        
        /**
         * Set custom animation sequence
         * @param {Array<number>} sequence Array of frame indices
         */
        setSequence(sequence) {
          if (!Array.isArray(sequence)) {
            console.error('Sequence must be an array of frame indices');
            return;
          }
          
          // Validate frames
          for (const frameIndex of sequence) {
            if (frameIndex < 0 || frameIndex >= this.frameCount) {
              console.error(`Invalid frame index in sequence: ${frameIndex}`);
              return;
            }
          }
          
          this.sequence = sequence;
          
          if (this.debug) {
            console.log(`Custom sequence set: ${sequence.join(', ')}`);
          }
        }
        
        /**
         * Clear custom animation sequence
         */
        clearSequence() {
          this.sequence = null;
          
          if (this.debug) {
            console.log('Custom sequence cleared');
          }
        }
        
        /**
         * Add event listener
         * @param {string} event Event name ('complete', 'framechange', or 'error')
         * @param {Function} callback Callback function
         */
        addEventListener(event, callback) {
          if (this.callbacks[event]) {
            this.callbacks[event].push(callback);
          } else {
            console.error(`Unknown event: ${event}`);
          }
        }
        
        /**
         * Remove event listener
         * @param {string} event Event name
         * @param {Function} callback Callback function
         */
        removeEventListener(event, callback) {
          if (this.callbacks[event]) {
            this.callbacks[event] = this.callbacks[event].filter(cb => cb !== callback);
          }
        }
        
        /**
         * Trigger event
         * @param {string} event Event name
         * @param {Object} data Event data
         * @private
         */
        triggerEvent(event, data = {}) {
          if (this.callbacks[event]) {
            for (const callback of this.callbacks[event]) {
              callback({
                type: event,
                target: this,
                ...data
              });
            }
          }
        }
        
        /**
         * Clean up resources
         */
        destroy() {
          // Stop animation
          this.pause();
          
          // Remove canvas from container
          if (this.canvas && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
          }
          
          // Clean up debug overlay
          if (this.debugOverlay && this.debugOverlay.parentNode) {
            this.debugOverlay.parentNode.removeChild(this.debugOverlay);
          }
          
          // Clean up references to DOM elements
          this.container = null;
          this.canvas = null;
          this.ctx = null;
          this.debugOverlay = null;
          
          // Clear event listeners
          this.callbacks = {
            complete: [],
            framechange: [],
            error: []
          };
          
          if (this.debug) {
            console.log('Animator destroyed and resources cleaned up');
          }
        }
    }
    </script>

    <!-- Sprite System Script -->
    <script>
        const SpriteSystem = {
            animations: {},
            nextId: 1,
            
            initialize() {
                console.log('Sprite Animation System initialized');
                return this;
            },
            
            createAnimation(characterId, container, options = {}) {
                const character = CharacterAssets.getCharacter(characterId);
                if (!character) {
                    console.error(`Character not found: ${characterId}`);
                    return null;
                }
                
                const animName = options.animation || 'idle';
                
                if (!character.animations || !character.animations[animName]) {
                    console.error(`Animation "${animName}" not found for character ${characterId}`);
                    return null;
                }
                
                const animData = character.animations[animName];
                
                // Use actual image path - KEY CHANGE
                const imagePath = character.spritePath + animData.file;
                
                // Create a default fallback for error cases
                let fallbackPath = '/static/img/placeholder.png';
                
                // Test mode placeholder (checkerboard instead of using a service)
                if (options.debug) {
                    console.log(`Loading sprite: ${imagePath}`);
                }
                
                const animator = new CanvasSpriteAnimator({
                    imagePath: imagePath,
                    fallbackImagePath: fallbackPath, // Add fallback path
                    frameCount: animData.frames || 1,
                    frameWidth: animData.width || 96,
                    frameHeight: animData.height 
                        ? Math.floor(animData.height / animData.frames)
                        : 96,
                    fps: animData.speed 
                        ? Math.floor(1000 / animData.speed) 
                        : 10,
                    scale: options.scale || 3,
                    loop: options.loop !== undefined ? options.loop : true,
                    autoPlay: options.autoPlay !== undefined ? options.autoPlay : true,
                    layout: animData.layout || 'vertical',
                    columns: animData.columns || 1,
                    rows: animData.rows || 1,
                    offsetX: animData.offsetX || 0,
                    offsetY: animData.offsetY || 0,
                    debug: options.debug || false
                });
                
                animator.mount(container);
                
                // Listen for errors
                animator.addEventListener('error', function(e) {
                    console.warn(`Sprite failed to load, showing fallback: ${e.path}`);
                });
                
                const id = `${characterId}_${this.nextId++}`;
                
                this.animations[id] = {
                    id,
                    animator,
                    character: characterId,
                    currentAnimation: animName,
                    container
                };
                
                if (options.onComplete) {
                    animator.addEventListener('complete', options.onComplete);
                }
                
                if (options.onFrameChange) {
                    animator.addEventListener('framechange', options.onFrameChange);
                }
                
                return id;
            },
            
            play(id) {
                const anim = this.animations[id];
                if (!anim) return false;
                
                anim.animator.play();
                return true;
            },
            
            pause(id) {
                const anim = this.animations[id];
                if (!anim) return false;
                
                anim.animator.pause();
                return true;
            },
            
            stop(id) {
                const anim = this.animations[id];
                if (!anim) return false;
                
                anim.animator.stop();
                return true;
            },
            
            goToFrame(id, frameIndex) {
                const anim = this.animations[id];
                if (!anim) return false;
                
                anim.animator.goToFrame(frameIndex);
                return true;
            },
            
            setSpeed(id, fps) {
                const anim = this.animations[id];
                if (!anim) return false;
                
                anim.animator.setSpeed(fps);
                return true;
            },
            
            setScale(id, scale) {
                const anim = this.animations[id];
                if (!anim) return false;
                
                anim.animator.setScale(scale);
                return true;
            },
            
            setSequence(id, sequence) {
                const anim = this.animations[id];
                if (!anim) return false;
                
                anim.animator.setSequence(sequence);
                return true;
            },
            
            clearSequence(id) {
                const anim = this.animations[id];
                if (!anim) return false;
                
                anim.animator.clearSequence();
                return true;
            },
            
            changeAnimation(id, animationName, options = {}) {
                const anim = this.animations[id];
                if (!anim) return false;
                
                const character = CharacterAssets.getCharacter(anim.character);
                if (!character) return false;
                
                if (!character.animations || !character.animations[animationName]) {
                    console.error(`Animation "${animationName}" not found for character ${anim.character}`);
                    return false;
                }
                
                const animData = character.animations[animationName];
                
                // Use actual image path - KEY CHANGE
                const imagePath = character.spritePath + animData.file;
                
                // Create a default fallback for error cases
                let fallbackPath = '/static/img/placeholder.png';
                
                anim.animator.destroy();
                
                const animator = new CanvasSpriteAnimator({
                    imagePath: imagePath,
                    fallbackImagePath: fallbackPath, // Add fallback path
                    frameCount: animData.frames || 1,
                    frameWidth: animData.width || 96,
                    frameHeight: animData.height 
                        ? Math.floor(animData.height / animData.frames)
                        : 96,
                    fps: animData.speed 
                        ? Math.floor(1000 / animData.speed) 
                        : 10,
                    scale: options.scale || anim.animator.scale,
                    loop: options.loop !== undefined ? options.loop : anim.animator.loop,
                    autoPlay: options.autoPlay !== undefined ? options.autoPlay : true,
                    layout: animData.layout || 'vertical',
                    columns: animData.columns || 1,
                    rows: animData.rows || 1,
                    offsetX: animData.offsetX || 0,
                    offsetY: animData.offsetY || 0,
                    debug: options.debug || anim.animator.debug
                });
                
                animator.mount(anim.container);
                
                anim.animator = animator;
                anim.currentAnimation = animationName;
                
                if (options.onComplete) {
                    animator.addEventListener('complete', options.onComplete);
                }
                
                if (options.onFrameChange) {
                    animator.addEventListener('framechange', options.onFrameChange);
                }
                
                return true;
            },
            
            onAnimationComplete(id, callback) {
                const anim = this.animations[id];
                if (!anim) return false;
                
                anim.animator.addEventListener('complete', callback);
                return true;
            },
            
            onFrameChange(id, callback) {
                const anim = this.animations[id];
                if (!anim) return false;
                
                anim.animator.addEventListener('framechange', callback);
                return true;
            },
            
            removeAnimation(id) {
                const anim = this.animations[id];
                if (!anim) return false;
                
                anim.animator.destroy();
                delete this.animations[id];
                return true;
            },
            
            getAnimationInfo(id) {
                const anim = this.animations[id];
                if (!anim) return null;
                
                return {
                    id: anim.id,
                    character: anim.character,
                    currentAnimation: anim.currentAnimation,
                    isPlaying: anim.animator.isPlaying,
                    currentFrame: anim.animator.currentFrame,
                    frameCount: anim.animator.frameCount,
                    fps: anim.animator.fps,
                    scale: anim.animator.scale
                };
            }
        };
        
        window.CanvasSpriteAnimator = CanvasSpriteAnimator;
        window.SpriteSystem = SpriteSystem;
        
        // Auto-initialize
        SpriteSystem.initialize();
    </script>
    
    <!-- Test Page Script -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize variables
            let currentCharacter1 = 'resident';
            let currentAnimation1 = 'idle';
            let animationId1 = null;
            
            let currentCharacter2 = 'resident';
            let animationId2 = null;
            let frameByFrameMode = false;
            
            // Initialize first animation test
            function initTest1() {
                // Create animation
                animationId1 = SpriteSystem.createAnimation(
                    currentCharacter1,
                    document.getElementById('sprite-display-1'),
                    {
                        animation: currentAnimation1,
                        scale: 3,
                        autoPlay: true,
                        debug: true
                    }
                );
                
                updateInfo1();
            }
            
            // Initialize second animation test
            function initTest2() {
                // Create animation
                animationId2 = SpriteSystem.createAnimation(
                    currentCharacter2,
                    document.getElementById('sprite-display-2'),
                    {
                        animation: 'idle',
                        scale: 3,
                        autoPlay: true,
                        debug: true,
                        onFrameChange: function(e) {
                            logEvent(`Frame changed: ${e.frame + 1}/${e.target.frameCount}`);
                            
                            // Update frame slider
                            const frameSlider = document.getElementById('frame-slider');
                            frameSlider.value = e.frame;
                        },
                        onComplete: function() {
                            logEvent('Animation completed');
                        }
                    }
                );
                
                // Update frame slider max value
                const frameSlider = document.getElementById('frame-slider');
                const info = SpriteSystem.getAnimationInfo(animationId2);
                frameSlider.max = info.frameCount - 1;
            }
            
            // Update info display for test 1
            function updateInfo1() {
                const info = SpriteSystem.getAnimationInfo(animationId1);
                if (!info) return;
                
                const infoEl = document.getElementById('sprite-info-1');
                infoEl.textContent = `Character: ${info.character}
Animation: ${info.currentAnimation}
Frame: ${info.currentFrame + 1}/${info.frameCount}
FPS: ${info.fps}
Scale: ${info.scale}
Playing: ${info.isPlaying}`;
            }
            
            // Log events for test 2
            function logEvent(message) {
                const logEl = document.getElementById('event-log');
                const timestamp = new Date().toLocaleTimeString();
                logEl.textContent = `[${timestamp}] ${message}\n${logEl.textContent.split('\n').slice(0, 10).join('\n')}`;
            }
            
            // Event handlers for test 1
            document.querySelectorAll('.test-card:first-child .character-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Update active state
                    document.querySelectorAll('.test-card:first-child .character-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // Change character
                    currentCharacter1 = this.dataset.character;
                    
                    // Update animation
                    if (animationId1) {
                        SpriteSystem.removeAnimation(animationId1);
                    }
                    initTest1();
                });
            });
            
            document.querySelectorAll('.animation-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Update active state
                    document.querySelectorAll('.animation-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // Change animation
                    currentAnimation1 = this.dataset.animation;
                    
                    // Update animation
                    if (animationId1) {
                        SpriteSystem.changeAnimation(animationId1, currentAnimation1);
                        updateInfo1();
                    }
                });
            });
            
            document.getElementById('play-btn-1').addEventListener('click', function() {
                if (animationId1) {
                    SpriteSystem.play(animationId1);
                    updateInfo1();
                }
            });
            
            document.getElementById('pause-btn-1').addEventListener('click', function() {
                if (animationId1) {
                    SpriteSystem.pause(animationId1);
                    updateInfo1();
                }
            });
            
            document.getElementById('stop-btn-1').addEventListener('click', function() {
                if (animationId1) {
                    SpriteSystem.stop(animationId1);
                    updateInfo1();
                }
            });
            
            document.getElementById('fps-slider-1').addEventListener('input', function() {
                if (animationId1) {
                    const fps = parseInt(this.value);
                    SpriteSystem.setSpeed(animationId1, fps);
                    document.getElementById('fps-value-1').textContent = fps;
                    updateInfo1();
                }
            });
            
            document.getElementById('scale-slider-1').addEventListener('input', function() {
                if (animationId1) {
                    const scale = parseFloat(this.value);
                    SpriteSystem.setScale(animationId1, scale);
                    document.getElementById('scale-value-1').textContent = scale;
                    updateInfo1();
                }
            });
            
            // Event handlers for test 2
            document.querySelectorAll('.test-card:last-child .character-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Update active state
                    document.querySelectorAll('.test-card:last-child .character-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // Change character
                    currentCharacter2 = this.dataset.character;
                    
                    // Update animation
                    if (animationId2) {
                        SpriteSystem.removeAnimation(animationId2);
                    }
                    initTest2();
                });
            });
            
            document.getElementById('custom-seq-btn').addEventListener('click', function() {
                if (animationId2) {
                    // Example: Ping-pong sequence
                    const info = SpriteSystem.getAnimationInfo(animationId2);
                    const frames = [];
                    
                    // Create ping-pong sequence (0, 1, 2, 3, 4, 3, 2, 1)
                    for (let i = 0; i < info.frameCount; i++) {
                        frames.push(i);
                    }
                    for (let i = info.frameCount - 2; i > 0; i--) {
                        frames.push(i);
                    }
                    
                    SpriteSystem.setSequence(animationId2, frames);
                    logEvent(`Custom sequence set: ${frames.join(', ')}`);
                    SpriteSystem.play(animationId2);
                }
            });
            
            document.getElementById('reset-seq-btn').addEventListener('click', function() {
                if (animationId2) {
                    SpriteSystem.clearSequence(animationId2);
                    logEvent('Custom sequence cleared');
                }
            });
            
            document.getElementById('frame-by-frame-btn').addEventListener('click', function() {
                if (animationId2) {
                    frameByFrameMode = !frameByFrameMode;
                    
                    if (frameByFrameMode) {
                        SpriteSystem.pause(animationId2);
                        this.textContent = 'Auto Play';
                        logEvent('Entered frame-by-frame mode');
                    } else {
                        SpriteSystem.play(animationId2);
                        this.textContent = 'Frame-by-Frame';
                        logEvent('Resumed auto play');
                    }
                }
            });
            
            document.getElementById('frame-slider').addEventListener('input', function() {
                if (animationId2 && frameByFrameMode) {
                    const frame = parseInt(this.value);
                    SpriteSystem.goToFrame(animationId2, frame);
                    document.getElementById('frame-value').textContent = frame;
                }
            });
            
            // Initialize tests
            initTest1();
            initTest2();
            
            // Set up interval to update info
            setInterval(updateInfo1, 100);
        });
    </script>
</body>
</html>